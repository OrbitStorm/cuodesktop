<?xml version="1.0"?>
<!--
Generated by VSdocman, see http://www.helixoft.com/net
-->
<doc>
  <assembly>
    <name>SharpZLib</name>
  </assembly>
  <members>
    <member name="N:ICSharpCode.SharpZipLib.BZip2">
</member>
    <member name="T:ICSharpCode.SharpZipLib.BZip2.BZip2">
      <summary>
 A helper class to simplify compressing and decompressing streams.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2.Decompress(System.IO.Stream,System.IO.Stream)">
      <summary>
 Decompress <paramref name="inStream">input</paramref> writing decompressed data to the <paramref name="outStream">output stream</paramref></summary>
      <param name="inStream">
The stream containing data to decompress.</param>
      <param name="outStream">
The stream to write decompressed data to.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2.Compress(System.IO.Stream,System.IO.Stream,System.Int32)">
      <summary>
 Compress <paramref name="inStream">input stream</paramref> sending result to <paramref name="outStream">output stream</paramref></summary>
      <param name="inStream">
The stream to compress.</param>
      <param name="outStream">
The stream to write compressed data to.</param>
      <param name="blockSize">
The block size to use.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.BZip2.BZip2Constants">
      <summary>
 Defines internal values for both compression and decompression</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.BZip2.BZip2Exception">
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2Exception.#ctor">
      <summary>
 Initialise a new instance of BZip2Exception.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2Exception.#ctor(System.String)">
      <summary>
 Initialise a new instance of BZip2Exception with its message set to message.</summary>
      <param name="message">
The message describing the error.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2Exception.#ctor(System.String,System.Exception)">
      <summary>
 Initialise an instance of BZip2Exception</summary>
      <param name="message">
A message describing the error.</param>
      <param name="exception">
The exception that is the cause of the current exception.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream">
      <summary>
 An input stream that decompresses files in the BZip2 format</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
      <summary>
 Construct instance for reading from stream</summary>
      <param name="stream">
Data source</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Flush">
      <summary>
 Flushes the stream.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 Set the streams position.  This operation is not supported and will throw a NotSupportedException</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.SetLength(System.Int64)">
      <summary>
 Sets the length of this stream to the given value. This operation is not supported and will throw a NotSupportedExceptionortedException</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes a block of bytes to this stream using data from a buffer. This operation is not supported and will throw a NotSupportedException</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.WriteByte(System.Byte)">
      <summary>
 Writes a byte to the current position in the file stream. This operation is not supported and will throw a NotSupportedException</summary>
      <param name="value">
The value to write.</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read a sequence of bytes and advances the read position by one byte.</summary>
      <returns>
The total number of bytes read into the buffer. This might be less
than the number of bytes requested if that number of bytes are not
currently available or zero if the end of the stream is reached.
</returns>
      <param name="buffer">
Array of bytes to store values in</param>
      <param name="offset">
Offset in array to begin storing data</param>
      <param name="count">
The maximum number of bytes to read</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Close">
      <summary>
 Closes the stream, releasing any associated resources.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.ReadByte">
      <summary>
 Read a byte from stream advancing position</summary>
      <returns>
byte read or -1 on end of stream</returns>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.CanRead">
      <summary>
 Gets a value indicating if the stream supports reading</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.CanSeek">
      <summary>
 Gets a value indicating whether the current stream supports seeking.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.CanWrite">
      <summary>
 Gets a value indicating whether the current stream supports writing. This property always returns false</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Length">
      <summary>
 Gets the length in bytes of the stream.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.Position">
      <summary>
 Gets or sets the streams position. Setting the position is not supported and will throw a NotSupportException</summary>
      <exception cref="NotSupportedException">
Any attempt to set the position</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2InputStream.IsStreamOwner">
      <summary>
 Get/set flag indicating ownership of underlying stream. When the flag is true <see cref="Close"></see> will close the underlying stream also.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream">
      <summary>
 An output stream that compresses into the BZip2 format including file header chars into another stream.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.#ctor(System.IO.Stream)">
      <summary>
 Construct a default output stream with maximum block size</summary>
      <param name="stream">
The stream to write BZip data onto.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Initialise a new instance of the <see cref="BZip2OutputStream"></see> for the specified stream, using the given blocksize.</summary>
      <remarks>

Valid block sizes are in the range 1..9, with 1 giving
the lowest compression and 9 the highest.
</remarks>
      <param name="stream">
The stream to write compressed data to.</param>
      <param name="blockSize">
The block size to use.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 Sets the current position of this stream to the given value.</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.SetLength(System.Int64)">
      <summary>
 Sets the length of this stream to the given value.</summary>
      <param name="value">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.ReadByte">
      <summary>
 Read a byte from the stream advancing the position.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read a block of bytes</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Write a block of bytes to the stream</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.WriteByte(System.Byte)">
      <summary>
 Write a byte to the stream.</summary>
      <param name="value">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Close">
      <summary>
 End the current block and end compression. Close the stream and free any resources</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Flush">
      <summary>
 Flush output buffers</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.IsStreamOwner">
      <summary>
 Get/set flag indicating ownership of underlying stream. When the flag is true <see cref="Close"></see> will close the underlying stream also.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Position">
      <summary>
 Gets or sets the current position of this stream.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.CanSeek">
      <summary>
 Gets a value indicating whether the current stream supports seeking</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.CanRead">
      <summary>
 Gets a value indicating whether the current stream supports reading</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.CanWrite">
      <summary>
 Gets a value indicating whether the current stream supports writing</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.Length">
      <summary>
 Gets the length in bytes of the stream</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream.BytesWritten">
      <summary>
 Get the number of bytes written to the output.</summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Checksums">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.Adler32">
      <summary>
 Computes Adler32 checksum for a stream of data. An Adler32 checksum is not as reliable as a CRC32 checksum, but a lot faster to compute.  The specification for Adler32 may be found in RFC 1950. ZLIB Compressed Data Format Specification version 3.3)   From that document:       "ADLER32 (Adler-32 checksum)       This contains a checksum value of the uncompressed data       (excluding any dictionary data) computed according to Adler-32       algorithm. This algorithm is a 32-bit extension and improvement       of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073       standard.        Adler-32 is composed of two sums accumulated per byte: s1 is       the sum of all bytes, s2 is the sum of all s1 values. Both sums       are done modulo 65521. s1 is initialized to 1, s2 to zero.  The       Adler-32 checksum is stored as s2*65536 + s1 in most-       significant-byte first (network) order."   "8.2. The Adler-32 algorithm     The Adler-32 algorithm is much faster than the CRC32 algorithm yet    still provides an extremely low probability of undetected errors.     The modulo on unsigned long accumulators can be delayed for 5552    bytes, so the modulo operation time is negligible.  If the bytes    are a, b, c, the second sum is 3a + 2b + c + 3, and so is position    and order sensitive, unlike the first sum, which is just a    checksum.  That 65521 is prime is important to avoid a possible    large class of two-byte errors that leave the check unchanged.    (The Fletcher checksum uses 255, which is not prime and which also    makes the Fletcher check insensitive to single byte changes 0 -    255.)     The sum s1 is initialized to 1 instead of zero to make the length    of the sequence part of s2, so that the length does not have to be    checked separately. (Any sequence of zeroes has a Fletcher    checksum of zero.)"</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.#ctor">
      <summary>
 Creates a new instance of the Adler32 class. The checksum starts off with a value of 1.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Reset">
      <summary>
 Resets the Adler32 checksum to the initial value.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
      <summary>
 Updates the checksum with a byte value.</summary>
      <param name="value">

The data value to add. The high byte of the int is ignored.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
      <summary>
 Updates the checksum with an array of bytes.</summary>
      <param name="buffer">

The source of the data to update with.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Updates the checksum with the bytes taken from the array.</summary>
      <param name="buffer">

an array of bytes
</param>
      <param name="offset">

the start of the data used for this update
</param>
      <param name="count">

the number of bytes to use for this update
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.Adler32.Value">
      <summary>
 Returns the Adler32 data checksum computed so far.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.Crc32">
      <summary>
 Generate a table for a byte-wise 32-bit CRC calculation on the polynomial: x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.  Polynomials over GF(2) are represented in binary, one bit per coefficient, with the lowest powers in the most significant bit.  Then adding polynomials is just exclusive-or, and multiplying a polynomial by x is a right shift by one.  If we call the above polynomial p, and represent a byte as the polynomial q, also with the lowest power in the most significant bit (so the byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p, where a mod b means the remainder after dividing a by b.  This calculation is done using the shift-register method of multiplying and taking the remainder.  The register is initialized to zero, and for each incoming bit, x^32 is added mod p to the register if the bit is a one (where x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x (which is shifting right by one and adding x^32 mod p if the bit shifted out is a one).  We start with the highest power (least significant bit) of q and repeat for all eight bits of q.  The table is simply the CRC of all possible eight bit values.  This is all the information needed to generate CRC's on data a byte at a time for all combinations of CRC register values and incoming bytes.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Reset">
      <summary>
 Resets the CRC32 data checksum as if no update was ever called.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
      <summary>
 Updates the checksum with the int bval.</summary>
      <param name="value">

the byte is taken as the lower 8 bits of value
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
      <summary>
 Updates the checksum with the bytes taken from the array.</summary>
      <param name="buffer">

buffer an array of bytes
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Adds the byte array to the data checksum.</summary>
      <param name="buffer">

The buffer which contains the data
</param>
      <param name="offset">

The offset in the buffer where the data starts
</param>
      <param name="count">

The number of data bytes to update the CRC with.
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.Crc32.Value">
      <summary>
 Returns the CRC32 data checksum computed so far.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Reset">
      <summary>
 Resets the data checksum as if no update was ever called.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
      <summary>
 Adds one byte to the data checksum.</summary>
      <param name="value">

the data value to add. The high byte of the int is ignored.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
      <summary>
 Updates the data checksum with the bytes taken from the array.</summary>
      <param name="buffer">

buffer an array of bytes
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Adds the byte array to the data checksum.</summary>
      <param name="buffer">

The buffer which contains the data
</param>
      <param name="offset">

The offset in the buffer where the data starts
</param>
      <param name="count">

the number of data bytes to add.
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.IChecksum.Value">
      <summary>
 Returns the data checksum computed so far.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Checksums.StrangeCRC">
      <summary>
 Bzip2 checksum algorithm</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.#ctor">
      <summary>
 Initialise a default instance of <see cref="StrangeCRC"></see></summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Reset">
      <summary>
 Reset the state of Crc.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Int32)">
      <summary>
 Update the Crc value.</summary>
      <param name="value">
data update is based on</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[])">
      <summary>
 Update Crc based on a block of data</summary>
      <param name="buffer">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Update Crc based on a portion of a block of data</summary>
      <param name="buffer">
block of data</param>
      <param name="offset">
index of first byte to use</param>
      <param name="count">
number of bytes to use</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Value">
      <summary>
 Get the current Crc value.</summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Core">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs">
      <summary>
 Event arguments for scanning.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ScanEventArgs.#ctor(System.String)">
      <summary>
 Initialise a new instance of <see cref="ScanEventArgs" /></summary>
      <param name="name">
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.Name">
      <summary>
 The name for this event.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.ContinueRunning">
      <summary>
 Get set a value indicating if scanning should continue or not.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs">
      <summary>
 Event arguments for directories.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.#ctor(System.String,System.Boolean)">
      <summary>
 Initialize an instance of <see cref="DirectoryEventArgs"></see>.</summary>
      <param name="name">
The name for this directory.</param>
      <param name="hasMatchingFiles">
Flag value indicating if any matching files are contained in this directory.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.HasMatchingFiles">
      <summary>
 Get a value indicating if the directory contains any matching files or not.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs">
      <summary>
 Arguments passed when scan failures are detected.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.#ctor(System.String,System.Exception)">
      <summary>
 Initialise a new instance of <see cref="ScanFailureEventArgs"></see></summary>
      <param name="name">
The name to apply.</param>
      <param name="e">
The exception to use.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Exception">
      <summary>
 The applicable exception.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.ContinueRunning">
      <summary>
 Get / set a value indicating wether scanning should continue.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Name">
      <summary>
 The applicable name.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner">
      <summary>
 FileSystemScanner provides facilities scanning of files and directories.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String)">
      <summary>
 Initialise a new instance of <see cref="FileSystemScanner"></see></summary>
      <param name="filter">
The <see cref="PathFilter">file filter</see> to apply when scanning.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String,System.String)">
      <summary>
 Initialise a new instance of <see cref="FileSystemScanner"></see></summary>
      <param name="fileFilter">
The <see cref="PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">
The <see cref="PathFilter">directory filter</see> to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter)">
      <summary>
 Initialise a new instance of <see cref="FileSystemScanner"></see></summary>
      <param name="fileFilter">
The file <see cref="IScanFilter"></see>filter to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter,ICSharpCode.SharpZipLib.Core.IScanFilter)">
      <summary>
 Initialise a new instance of <see cref="FileSystemScanner"></see></summary>
      <param name="fileFilter">
The file <see cref="IScanFilter"></see>filter to apply.</param>
      <param name="directoryFilter">
The directory <see cref="IScanFilter"></see>filter to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnDirectoryFailure(System.String,System.Exception)">
      <summary>
 Raise the DirectoryFailure event.</summary>
      <param name="directory">
The directory name.</param>
      <param name="e">
The exception detected.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnFileFailure(System.String,System.Exception)">
      <summary>
 Raise the FileFailure event.</summary>
      <param name="file">
The file name.</param>
      <param name="e">
The exception detected.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnProcessFile(System.String)">
      <summary>
 Raise the ProcessFile event.</summary>
      <param name="file">
The file name.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnProcessDirectory(System.String,System.Boolean)">
      <summary>
 Raise the ProcessDirectory event.</summary>
      <param name="directory">
The directory name.</param>
      <param name="hasMatchingFiles">
Flag indicating if the directory has matching files.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.Scan(System.String,System.Boolean)">
      <summary>
 Scan a directory.</summary>
      <param name="directory">
The base directory to scan.</param>
      <param name="recurse">
True to recurse subdirectories, false to scan a single directory.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformFile(System.String)">
      <summary>
 Given a file name determine the transformed value.</summary>
      <returns>
The transformed file name.</returns>
      <param name="name">
The name to transform.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformDirectory(System.String)">
      <summary>
 Given a directory name determine the transformed value.</summary>
      <returns>
The transformed directory name</returns>
      <param name="name">
The name to transform.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.IScanFilter.IsMatch(System.String)">
      <summary>
 Test a name to see if it 'matches' the filter.</summary>
      <returns>
Returns true if the name matches the filter, false if it does not match.</returns>
      <param name="name">
The name to test.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.NameFilter">
      <summary>
 NameFilter is a string matching class which allows for both positive and negative matching. A filter is a sequence of independant <see cref="Regex">regular expressions</see> separated by semi-colons ';' Each expression can be prefixed by a plus '+' sign or a minus '-' sign to denote the expression is intended to include or exclude names.  If neither a plus or minus sign is found include is the default A given name is tested for inclusion before checking exclusions.  Only names matching an include spec and not matching an exclude spec are deemed to match the filter. An empty filter matches any name.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.#ctor(System.String)">
      <summary>
 Construct an instance based on the filter expression passed</summary>
      <param name="filter">
The filter expression.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidExpression(System.String)">
      <summary>
 Test a string to see if it is a valid regular expression.</summary>
      <returns>
True if expression is a valid <see cref="System.Text.RegularExpressions.Regex" /> false otherwise.</returns>
      <param name="expression">
The expression to test.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidFilterExpression(System.String)">
      <summary>
 Test an expression to see if it is valid as a filter.</summary>
      <returns>
True if the expression is valid, false otherwise.</returns>
      <param name="toTest">
The filter expression to test.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.ToString">
      <summary>
 Convert this filter to its string equivalent.</summary>
      <returns>
The string equivalent for this filter.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsIncluded(System.String)">
      <summary>
 Test a value to see if it is included by the filter.</summary>
      <returns>
True if the value is included, false otherwise.</returns>
      <param name="name">
The value to test.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsExcluded(System.String)">
      <summary>
 Test a value to see if it is excluded by the filter.</summary>
      <returns>
True if the value is excluded, false otherwise.</returns>
      <param name="name">
The value to test.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsMatch(System.String)">
      <summary>
 Test a value to see if it matches the filter.</summary>
      <returns>
True if the value matches, false otherwise.</returns>
      <param name="name">
The value to test.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.PathFilter">
      <summary>
 PathFilter filters directories and files using a form of <see cref="System.Text.RegularExpressions.Regex">regular expressions</see> by full path name. See <see cref="NameFilter">NameFilter</see> for more detail on filtering.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.#ctor(System.String)">
      <summary>
 Initialise a new instance of <see cref="PathFilter"></see>.</summary>
      <param name="filter">
The <see cref="NameFilter"></see>filter expression to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.IsMatch(System.String)">
      <summary>
 Test a name to see if it matches the filter.</summary>
      <returns>
True if the name matches, false otherwise.</returns>
      <param name="name">
The name to test.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter">
      <summary>
 ExtendedPathFilter filters based on name, file size, and the last write time of the file.</summary>
      <remarks>
Provides an example of how to customise filtering.</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64)">
      <summary>
 Initialise a new instance of ExtendedPathFilter.</summary>
      <param name="filter">
The filter to apply.</param>
      <param name="minSize">
The minimum file size to include.</param>
      <param name="maxSize">
The maximum file size to include.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.DateTime,System.DateTime)">
      <summary>
 Initialise a new instance of ExtendedPathFilter.</summary>
      <param name="filter">
The filter to apply.</param>
      <param name="minDate">
The minimum <see cref="DateTime" /> to include.</param>
      <param name="maxDate">
The maximum <see cref="DateTime" /> to include.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64,System.DateTime,System.DateTime)">
      <summary>
 Initialise a new instance of ExtendedPathFilter.</summary>
      <param name="filter">
The filter to apply.</param>
      <param name="minSize">
The minimum file size to include.</param>
      <param name="maxSize">
The maximum file size to include.</param>
      <param name="minDate">
The minimum <see cref="DateTime" /> to include.</param>
      <param name="maxDate">
The maximum <see cref="DateTime" /> to include.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.IsMatch(System.String)">
      <summary>
 Test a filename to see if it matches the filter.</summary>
      <returns>
True if the filter matches, false otherwise.</returns>
      <param name="name">
The filename to test.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxDate">
      <summary>
 Get/set the maximum <see cref="DateTime" /> value that will match for this filter.</summary>
      <remarks>
Files with a LastWrite time greater than this value are excluded by the filter.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinDate">
      <summary>
 Get/set the minimum <see cref="DateTime" /> value that will match for this filter.</summary>
      <remarks>
Files with a LastWrite time less than this value are excluded by the filter.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxSize">
      <summary>
 Get/set the maximum size for a file that will match this filter.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinSize">
      <summary>
 Get/set the minimum size for a file that will match this filter.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter">
      <summary>
 NameAndSizeFilter filters based on name and file size.</summary>
      <remarks>
A sample showing how filters might be extended.</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.#ctor(System.String,System.Int64,System.Int64)">
      <summary>
 Initialise a new instance of NameAndSizeFilter.</summary>
      <param name="filter">
The filter to apply.</param>
      <param name="minSize">
The minimum file size to include.</param>
      <param name="maxSize">
The maximum file size to include.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.IsMatch(System.String)">
      <summary>
 Test a filename to see if it matches the filter.</summary>
      <returns>
True if the filter matches, false otherwise.</returns>
      <param name="name">
The filename to test.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MinSize">
      <summary>
 Get/set the minimum size for a file that will match this filter.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MaxSize">
      <summary>
 Get/set the maximum size for a file that will match this filter.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Core.StreamUtils">
      <summary>
 Provides simple <see cref="Stream" />" utilities.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
      <summary>
 Read from a <see cref="Stream" /> ensuring all the required data is read.</summary>
      <param name="stream">
The stream to read.</param>
      <param name="buffer">
The buffer to fill.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read from a <see cref="Stream" />" ensuring all the required data is read.</summary>
      <param name="stream">
The stream to read data from.</param>
      <param name="buffer">
The buffer to store data in.</param>
      <param name="offset">
The offset at which to begin storing data.</param>
      <param name="count">
The number of bytes of data to store.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
      <summary>
 Copy the contents of one <see cref="Stream" /> to another.</summary>
      <param name="source">
The stream to source data from.</param>
      <param name="destination">
The stream to write data to.</param>
      <param name="buffer">
The buffer to use during copying.</param>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Encryption">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassic">
      <summary>
 PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives. While it has been superceded by more recent and more powerful algorithms, its still in use and is viable for preventing casual snooping</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
      <summary>
 Generates new encryption keys based on given seed</summary>
      <param name="seed">
</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged">
      <summary>
 Defines a wrapper object to access the Pkzip algorithm. This class cannot be inherited.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
      <summary>
 Generate an initial vector.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
      <summary>
 Generate a new random key.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>
 Create an encryptor.</summary>
      <returns>
Returns a new PkzipClassic encryptor</returns>
      <param name="rgbKey">
The key to use for this encryptor.</param>
      <param name="rgbIV">
Initialisation vector for the new encryptor.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>
 Create a decryptor.</summary>
      <returns>
Returns a new decryptor.</returns>
      <param name="rgbKey">
Keys to use for this new decryptor.</param>
      <param name="rgbIV">
Initialisation vector for the new decryptor.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
      <summary>
 Get / set the applicable block size in bits.</summary>
      <remarks>
The only valid block size is 8.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.Key">
      <summary>
 Get / set the key value applicable.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
      <summary>
 Get an array of legal <see cref="KeySizes">block sizes</see>.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
      <summary>
 Get an array of legal <see cref="KeySizes">key sizes.</see></summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib.GZip">
</member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipConstants">
      <summary>
 This class contains constants used for gzip.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipException">
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor">
      <summary>
 Initialise a new instance of GZipException</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String)">
      <summary>
 Initialise a new instance of GZipException with its message string.</summary>
      <param name="message">
A <see cref="string" /> that describes the error.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String,System.Exception)">
      <summary>
 Initialise a new instance of <see cref="GZipException"></see>.</summary>
      <param name="message">
A <see cref="string" /> that describes the error.</param>
      <param name="innerException">
The <see cref="Exception" /> that caused this exception.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipInputStream">
      <summary>
 This filter stream is used to decompress a "GZIP" format stream. The "GZIP" format is described baseInputStream RFC 1952.  author of the original java version : John Leuner</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream)">
      <summary>
 Creates a GzipInputStream with the default buffer size</summary>
      <param name="baseInputStream">

The stream to read compressed data from (baseInputStream GZIP format)
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Creates a GZIPInputStream with the specified buffer size</summary>
      <param name="baseInputStream">

The stream to read compressed data from (baseInputStream GZIP format)
</param>
      <param name="size">

Size of the buffer to use
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Reads uncompressed data into an array of bytes</summary>
      <param name="buffer">

The buffer to read uncompressed data into
</param>
      <param name="offset">

The offset indicating where the data should be placed
</param>
      <param name="count">

The number of uncompressed bytes to be read
</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.GZip.GZipOutputStream">
      <summary>
 This filter stream is used to compress a stream into a "GZIP" stream. The "GZIP" format is described in RFC 1952.  author of the original java version : John Leuner</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream)">
      <summary>
 Creates a GzipOutputStream with the default buffer size</summary>
      <param name="baseOutputStream">

The stream to read data (to be compressed) from
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Creates a GZipOutputStream with the specified buffer size</summary>
      <param name="baseOutputStream">

The stream to read data (to be compressed) from
</param>
      <param name="size">

Size of the buffer to use
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.SetLevel(System.Int32)">
      <summary>
 Sets the active compression level (1-9).  The new level will be activated immediately.</summary>
      <param name="level">
</param>
      <exception cref="ArgumentOutOfRangeException">

Level specified is not supported.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.GetLevel">
      <summary>
 Get the current compression level.</summary>
      <returns>
The current compression level.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Write given buffer to output updating crc</summary>
      <param name="buffer">
Buffer to write</param>
      <param name="offset">
Offset of first byte in buf to write</param>
      <param name="count">
Number of bytes to write</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Close">
      <summary>
 Writes remaining compressed output data to the output stream and closes it.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Finish">
      <summary>
 Finish compression and write any footer information required to stream</summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib">
</member>
    <member name="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
</member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor">
      <summary>
 Initializes a new instance of the SharpZipBaseException class.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
      <summary>
 Initializes a new instance of the SharpZipBaseException class with a specified error message.</summary>
      <param name="msg">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
      <summary>
 Initializes a new instance of the SharpZipBaseException class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">
Error message string</param>
      <param name="innerException">
The inner exception</param>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Tar">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.InvalidHeaderException">
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.InvalidHeaderException.#ctor">
      <summary>
 Initialise a new instance of the InvalidHeaderException class.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.InvalidHeaderException.#ctor(System.String)">
      <summary>
 Initialises a new instance of the InvalidHeaderException class with a specified message.</summary>
      <param name="message">
Message describing the exception cause.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.InvalidHeaderException.#ctor(System.String,System.Exception)">
      <summary>
 Initialise a new instance of InvalidHeaderException</summary>
      <param name="message">
Message describing the problem.</param>
      <param name="exception">
The exception that is the cause of the current exception.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarArchive">
      <summary>
 The TarArchive class implements the concept of a 'Tape Archive'. A tar archive is a series of entries, each of which represents a file system object. Each entry in the archive consists of a header block followed by 0 or more data blocks. Directory entries consist only of the header block, and are followed by entries for the directory's contents. File entries consist of a header followed by the number of blocks needed to contain the file's contents. All entries are written on block boundaries. Blocks are 512 bytes long.  TarArchives are instantiated in either read or write mode, based upon whether they are instantiated with an InputStream or an OutputStream. Once instantiated TarArchives read/write mode can not be changed.  There is currently no support for random access to tar archives. However, it seems that subclassing TarArchive, and using the TarBuffer.CurrentRecord and TarBuffer.CurrentBlock properties, this would be rather trivial.</summary>
</member>
    <member name="E:ICSharpCode.SharpZipLib.Tar.TarArchive.ProgressMessageEvent">
      <summary>
 Client hook allowing detailed information to be reported during processing</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.CreateInputTarArchive(System.IO.Stream)">
      <summary>
 The InputStream based constructors create a TarArchive for the purposes of extracting or listing a tar archive. Thus, use these constructors when you wish to extract files from or list the contents of an existing tar archive.</summary>
      <param name="inputStream">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.CreateInputTarArchive(System.IO.Stream,System.Int32)">
      <summary>
 Create TarArchive for reading setting block factor</summary>
      <returns>

TarArchive
</returns>
      <param name="inputStream">
Stream for tar archive contents</param>
      <param name="blockFactor">
The blocking factor to apply</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.CreateOutputTarArchive(System.IO.Stream)">
      <summary>
 Create a TarArchive for writing to, using the default blocking factor</summary>
      <param name="outputStream">
Stream to write to</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.CreateOutputTarArchive(System.IO.Stream,System.Int32)">
      <summary>
 Create a TarArchive for writing to</summary>
      <param name="outputStream">
The stream to write to</param>
      <param name="blockFactor">
The blocking factor to use for buffering.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.SetKeepOldFiles(System.Boolean)">
      <summary>
 Set the flag that determines whether existing files are kept, or overwritten during extraction.</summary>
      <param name="keepOldFiles">

If true, do not overwrite existing files.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.SetAsciiTranslation(System.Boolean)">
      <summary>
 Set the ascii file translation flag.</summary>
      <param name="asciiTranslate">

If true, translate ascii text files.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.SetUserInfo(System.Int32,System.String,System.Int32,System.String)">
      <summary>
 Set user and group information that will be used to fill in the tar archive's entry headers. This information based on that available for the linux operating system, which is not always available on other operating systems.  TarArchive allows the programmer to specify values to be used in their place. <see cref="ApplyUserInfoOverrides" /> is set to true by this call.</summary>
      <param name="userId">

The user id to use in the headers.
</param>
      <param name="userName">

The user name to use in the headers.
</param>
      <param name="groupId">

The group id to use in the headers.
</param>
      <param name="groupName">

The group name to use in the headers.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.CloseArchive">
      <summary>
 Close the archive.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.ListContents">
      <summary>
 Perform the "list" command for the archive contents.  NOTE That this method uses the <see cref="ProgressMessageEvent"> progress event</see> to actually list the contents. If the progress display event is not set, nothing will be listed!</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.ExtractContents(System.String)">
      <summary>
 Perform the "extract" command and extract the contents of the archive.</summary>
      <param name="destinationDirectory">

The destination directory into which to extract.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.WriteEntry(ICSharpCode.SharpZipLib.Tar.TarEntry,System.Boolean)">
      <summary>
 Write an entry to the archive. This method will call the putNextEntry and then write the contents of the entry, and finally call closeEntry() for entries that are files. For directories, it will call putNextEntry(), and then, if the recurse flag is true, process each entry that is a child of the directory.</summary>
      <param name="sourceEntry">

The TarEntry representing the entry to write to the archive.
</param>
      <param name="recurse">

If true, process the children of directory entries.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarArchive.Close">
      <summary>
 Closes the archive and releases any associated resources.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.GroupId">
      <summary>
 Get the archive group id. See <see cref="ApplyUserInfoOverrides">ApplyUserInfoOverrides</see> for detail on how to allow setting values on a per entry basis.</summary>
      <value>

The current group id.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.PathPrefix">
      <summary>
 PathPrefix is added to entry names as they are written if the value is not null. A slash character is appended after PathPrefix</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.RootPath">
      <summary>
 RootPath is removed from entry names if it is found at the beginning of the name.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.UserName">
      <summary>
 Get the archive user name. See <see cref="ApplyUserInfoOverrides">ApplyUserInfoOverrides</see> for detail on how to allow setting values on a per entry basis.</summary>
      <value>

The current user name.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.GroupName">
      <summary>
 Get the archive group name. See <see cref="ApplyUserInfoOverrides">ApplyUserInfoOverrides</see> for detail on how to allow setting values on a per entry basis.</summary>
      <value>

The current group name.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.AsciiTranslate">
      <summary>
 Get/set the ascii file translation flag. If ascii file translation is true, then the file is checked to see if it a binary file or not. If the flag is true and the test indicates it is ascii text file, it will be translated. The translation converts the local operating system's concept of line ends into the UNIX line end, '\n', which is the defacto standard for a TAR archive. This makes text files compatible with UNIX.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.RecordSize">
      <summary>
 Get the archive's record size. Tar archives are composed of a series of RECORDS each containing a number of BLOCKS. This allowed tar archives to match the IO characteristics of the physical device being used. Archives are expected to be properly "blocked".</summary>
      <value>

The record size this archive is using.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.ApplyUserInfoOverrides">
      <summary>
 Get or set a value indicating if overrides defined by <see cref="SetUserInfo">SetUserInfo</see> should be applied.</summary>
      <remarks>
If overrides are not applied then the values as set in each header will be used.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarArchive.UserId">
      <summary>
 Get the archive user id. See <see cref="ApplyUserInfoOverrides">ApplyUserInfoOverrides</see> for detail on how to allow setting values on a per entry basis.</summary>
      <value>

The current user id.
</value>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarBuffer">
      <summary>
 The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct "record" size, or other tars will complain. <p> You should never have a need to access this class directly. TarBuffers are created by Tar IO Streams. </p></summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.GetRecordSize">
      <summary>
 Get the TAR Buffer's record size.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.GetBlockFactor">
      <summary>
 Get the TAR Buffer's block factor</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.CreateInputTarBuffer(System.IO.Stream)">
      <summary>
 Create TarBuffer for reading with default BlockFactor</summary>
      <returns>
TarBuffer</returns>
      <param name="inputStream">
Stream to buffer</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.CreateInputTarBuffer(System.IO.Stream,System.Int32)">
      <summary>
 Construct TarBuffer for reading inputStream setting BlockFactor</summary>
      <returns>
TarBuffer</returns>
      <param name="inputStream">
Stream to buffer</param>
      <param name="blockFactor">
Blocking factor to apply</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.CreateOutputTarBuffer(System.IO.Stream)">
      <summary>
 Construct TarBuffer for writing with default BlockFactor</summary>
      <returns>
TarBuffer</returns>
      <param name="outputStream">
output stream for buffer</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.CreateOutputTarBuffer(System.IO.Stream,System.Int32)">
      <summary>
 Construct TarBuffer for writing Tar output to streams.</summary>
      <returns>
TarBuffer</returns>
      <param name="outputStream">
Output stream to write to.</param>
      <param name="blockFactor">
Blocking factor to apply</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.IsEOFBlock(System.Byte[])">
      <summary>
 Determine if an archive block indicates End of Archive. End of archive is indicated by a block that consists entirely of null bytes. All remaining blocks for the record should also be null's However some older tars only do a couple of null blocks (Old GNU tar for one) and also partial records</summary>
      <param name="block">
The data block to check.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.SkipBlock">
      <summary>
 Skip over a block on the input stream.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.ReadBlock">
      <summary>
 Read a block from the input stream.</summary>
      <returns>

The block of data read.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.GetCurrentBlockNum">
      <summary>
 Get the current block number, within the current record, zero based.</summary>
      <remarks>

The absolute block number = (<see cref="GetCurrentRecordNum">record number</see> * <see cref="BlockFactor">block factor</see>) + <see cref="GetCurrentBlockNum">block number</see>.
</remarks>
      <returns>

The current zero based block number.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.GetCurrentRecordNum">
      <summary>
 Get the current record number.</summary>
      <returns>

The current zero based record number.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.WriteBlock(System.Byte[])">
      <summary>
 Write a block of data to the archive.</summary>
      <param name="block">

The data to write to the archive.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.WriteBlock(System.Byte[],System.Int32)">
      <summary>
 Write an archive record to the archive, where the record may be inside of a larger array buffer. The buffer must be "offset plus record size" long.</summary>
      <param name="buffer">

The buffer containing the record data to write.
</param>
      <param name="offset">

The offset of the record data within buffer.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarBuffer.Close">
      <summary>
 Close the TarBuffer. If this is an output buffer, also flush the current block before closing.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarBuffer.CurrentRecord">
      <summary>
 Get the current record number.</summary>
      <value>

The current zero based record number.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarBuffer.BlockFactor">
      <summary>
 Get the Blocking factor for the buffer</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarBuffer.RecordSize">
      <summary>
 Get the record size for this buffer</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarBuffer.CurrentBlock">
      <summary>
 Get the current block number, within the current record, zero based.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarEntry">
      <summary>
 This class represents an entry in a Tar archive. It consists of the entry's header, as well as the entry's File. Entries can be instantiated in one of three ways, depending on how they are to be used. <p> TarEntries that are created from the header bytes read from an archive are instantiated with the TarEntry( byte[] ) constructor. These entries will be used when extracting from or listing the contents of an archive. These entries have their header filled in using the header bytes. They also set the File to null, since they reference an archive entry not a file.</p> <p> TarEntries that are created from files that are to be written into an archive are instantiated with the CreateEntryFromFile(string) pseudo constructor. These entries have their header filled in using the File's information. They also keep a reference to the File for convenience when writing entries.</p> <p> Finally, TarEntries can be constructed from nothing but a name. This allows the programmer to construct the entry by hand, for instance when only an InputStream is available for writing to the archive, and the header information is constructed from other information. In this case the header fields are set to defaults and the File is set to null.</p> <see cref="TarHeader" /></summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.#ctor(System.Byte[])">
      <summary>
 Construct an entry from an archive's header bytes. File is set to null.</summary>
      <param name="headerBuffer">

The header bytes from a tar archive entry.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.#ctor(ICSharpCode.SharpZipLib.Tar.TarHeader)">
      <summary>
 Construct a TarEntry using the <paramref name="header">header</paramref> provided</summary>
      <param name="header">
Header details for entry</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.Clone">
      <summary>
 Clone this tar entry.</summary>
      <returns>
Returns a clone of this entry.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.CreateTarEntry(System.String)">
      <summary>
 Construct an entry with only a <paramref name="name">name</paramref>. This allows the programmer to construct the entry's header "by hand".</summary>
      <param name="name">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.CreateEntryFromFile(System.String)">
      <summary>
 Construct an entry for a file. File is set to file, and the header is constructed from information from the file.</summary>
      <param name="fileName">

The file that the entry represents.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.Equals(System.Object)">
      <summary>
 Determine if the two entries are equal. Equality is determined by the header names being equal.</summary>
      <returns>

True if the entries are equal.
</returns>
      <param name="obj">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.GetHashCode">
      <summary>
 Must be overridden when you override Equals.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.IsDescendent(ICSharpCode.SharpZipLib.Tar.TarEntry)">
      <summary>
 Determine if the given entry is a descendant of this entry. Descendancy is determined by the name of the descendant starting with this entry's name.</summary>
      <returns>

True if entry is a descendant of this.
</returns>
      <param name="toTest">

Entry to be checked as a descendent of this.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.SetIds(System.Int32,System.Int32)">
      <summary>
 Convenience method to set this entry's group and user ids.</summary>
      <param name="userId">

This entry's new user id.
</param>
      <param name="groupId">

This entry's new group id.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.SetNames(System.String,System.String)">
      <summary>
 Convenience method to set this entry's group and user names.</summary>
      <param name="userName">

This entry's new user name.
</param>
      <param name="groupName">

This entry's new group name.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.GetFileTarHeader(ICSharpCode.SharpZipLib.Tar.TarHeader,System.String)">
      <summary>
 Fill in a TarHeader with information from a File.</summary>
      <param name="header">

The TarHeader to fill in.
</param>
      <param name="file">

The file from which to get the header information.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.GetDirectoryEntries">
      <summary>
 Get entries for all files present in this entries directory. If this entry doesnt represent a directory zero entries are returned.</summary>
      <returns>

An array of TarEntry's for this entry's children.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.WriteEntryHeader(System.Byte[])">
      <summary>
 Write an entry's header information to a header buffer.</summary>
      <param name="outBuffer">

The tar entry header buffer to fill in.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.AdjustEntryName(System.Byte[],System.String)">
      <summary>
 Convenience method that will modify an entry's name directly in place in an entry header buffer byte array.</summary>
      <param name="buffer">

The buffer containing the entry header to modify.
</param>
      <param name="newName">

The new name to place into the header buffer.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarEntry.NameTarHeader(ICSharpCode.SharpZipLib.Tar.TarHeader,System.String)">
      <summary>
 Fill in a TarHeader given only the entry's name.</summary>
      <param name="header">

The TarHeader to fill in.
</param>
      <param name="name">

The tar entry name.
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.GroupName">
      <summary>
 Get/set this entry's group name.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.ModTime">
      <summary>
 Get/Set the modification time for this entry</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.TarHeader">
      <summary>
 Get this entry's header.</summary>
      <value>

This entry's TarHeader.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.File">
      <summary>
 Get this entry's file.</summary>
      <value>

This entry's file.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.GroupId">
      <summary>
 Get/set this entry's group id.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.Size">
      <summary>
 Get/set this entry's recorded file size.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.IsDirectory">
      <summary>
 Return true if this entry represents a directory, false otherwise</summary>
      <value>

True if this entry is a directory.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.Name">
      <summary>
 Get/Set this entry's name.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.UserId">
      <summary>
 Get/set this entry's user id.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarEntry.UserName">
      <summary>
 Get/set this entry's user name.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarException">
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarException.#ctor">
      <summary>
 Initialises a new instance of the TarException class.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarException.#ctor(System.String)">
      <summary>
 Initialises a new instance of the TarException class with a specified message.</summary>
      <param name="message">
The message that describes the error.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarException.#ctor(System.String,System.Exception)">
      <param name="message">
A message describing the error.</param>
      <param name="exception">
The exception that is the cause of the current exception.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarHeader">
      <summary>
 This class encapsulates the Tar Entry Header used in Tar Archives. The class also holds a number of tar constants, used mostly in headers.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.#ctor">
      <summary>
 Initialise a default TarHeader instance</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetName">
      <summary>
 Get the name of this entry.</summary>
      <returns>
The entry's name.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.Clone">
      <summary>
 Clone a TAR header.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.ParseBuffer(System.Byte[])">
      <summary>
 Parse TarHeader information from a header buffer.</summary>
      <param name="header">

The tar entry header buffer to get information from.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.WriteHeader(System.Byte[])">
      <summary>
 'Write' header information to buffer provided, updating the <see cref="Checksum">check sum</see>.</summary>
      <param name="outBuffer">
output buffer for header information</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetHashCode">
      <summary>
 Get a hash code for the current object.</summary>
      <returns>
A hash code for the current object.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.Equals(System.Object)">
      <summary>
 Determines if this instance is equal to the specified object.</summary>
      <returns>
true if the objects are equal, false otherwise.</returns>
      <param name="obj">
The object to compare with.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.ParseOctal(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Parse an octal string from a header buffer.</summary>
      <returns>
The long equivalent of the octal string.</returns>
      <param name="header">
The header buffer from which to parse.</param>
      <param name="offset">
The offset into the buffer from which to parse.</param>
      <param name="length">
The number of header bytes to parse.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.ParseName(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Parse a name from a header buffer.</summary>
      <returns>

The name parsed.
</returns>
      <param name="header">

The header buffer from which to parse.
</param>
      <param name="offset">

The offset into the buffer from which to parse.
</param>
      <param name="length">

The number of header bytes to parse.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetNameBytes(System.Text.StringBuilder,System.Int32,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add <paramref name="name">name</paramref> to the buffer as a collection of bytes</summary>
      <returns>
The next free index in the <paramref name="buf">buffer</paramref></returns>
      <param name="name">
The name to add</param>
      <param name="nameOffset">
The offset of the first character</param>
      <param name="buffer">
The buffer to add to</param>
      <param name="bufferOffset">
The index of the first byte to add</param>
      <param name="length">
The number of characters/bytes to add</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetNameBytes(System.String,System.Int32,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add <paramref name="name">name</paramref> to the buffer as a collection of bytes</summary>
      <returns>
The next free index in the <paramref name="buf">buffer</paramref></returns>
      <param name="name">
The name to add</param>
      <param name="nameOffset">
The offset of the first character</param>
      <param name="buffer">
The buffer to add to</param>
      <param name="bufferOffset">
The index of the first byte to add</param>
      <param name="length">
The number of characters/bytes to add</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetNameBytes(System.Text.StringBuilder,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add an entry name to the buffer</summary>
      <returns>

The index of the next free byte in the buffer
</returns>
      <param name="name">

The name to add
</param>
      <param name="buffer">

The buffer to add to
</param>
      <param name="offset">

The offset into the buffer from which to start adding
</param>
      <param name="length">

The number of header bytes to add
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetNameBytes(System.String,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add an entry name to the buffer</summary>
      <returns>
The index of the next free byte in the buffer</returns>
      <param name="name">
The name to add</param>
      <param name="buffer">
The buffer to add to</param>
      <param name="offset">
The offset into the buffer from which to start adding</param>
      <param name="length">
The number of header bytes to add</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetAsciiBytes(System.String,System.Int32,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add a string to a buffer as a collection of ascii bytes.</summary>
      <returns>
The next free index in the buffer.</returns>
      <param name="toAdd">
The string to add</param>
      <param name="nameOffset">
The offset of the first character to add.</param>
      <param name="buffer">
The buffer to add to.</param>
      <param name="bufferOffset">
The offset to start adding at.</param>
      <param name="length">
The number of ascii characters to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetOctalBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Put an octal representation of a value into a buffer</summary>
      <returns>

The offset of the character next byte after the octal string
</returns>
      <param name="value">

the value to be converted to octal
</param>
      <param name="buffer">

buffer to store the octal string
</param>
      <param name="offset">

The offset into the buffer where the value starts
</param>
      <param name="length">

The length of the octal string to create
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarHeader.GetLongOctalBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
      <summary>
 Put an octal representation of a value into a buffer</summary>
      <returns>
Index of next byte</returns>
      <param name="value">
Value to be convert to octal</param>
      <param name="buffer">
The buffer to update</param>
      <param name="offset">
The offset into the buffer to store the value</param>
      <param name="length">
The length of the octal string</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Checksum">
      <summary>
 Get the entry's checksum.  This is only valid/updated after writing or reading an entry.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.LinkName">
      <summary>
 The entry's link name.</summary>
      <exception cref="ArgumentNullException">
Thrown when attempting to set LinkName to null.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.UserName">
      <summary>
 The entry's user name.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.DevMajor">
      <summary>
 Get/set the entry's major device number.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Name">
      <summary>
 Get/set the name for this tar entry.</summary>
      <exception cref="ArgumentNullException">
Thrown when attempting to set the property to null.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.DevMinor">
      <summary>
 Get/set the entry's minor device number.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.ModTime">
      <summary>
 Get/set the entry's modification time.</summary>
      <remarks>

The modification time is only accurate to within a second.
</remarks>
      <exception cref="ArgumentOutOfRangeException">
Thrown when setting the date time to less than 1/1/1970.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Size">
      <summary>
 Get/set the entry's size.</summary>
      <exception cref="ArgumentOutOfRangeException">
Thrown when setting the size to less than zero.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.GroupName">
      <summary>
 Get/set the entry's group name.</summary>
      <remarks>

This is only directly relevant to unix systems.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.IsChecksumValid">
      <summary>
 Get value of true if the header checksum is valid, false otherwise.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Version">
      <summary>
 The entry's version.</summary>
      <exception cref="ArgumentNullException">
Thrown when attempting to set Version to null.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.UserId">
      <summary>
 The entry's user id.</summary>
      <remarks>

This is only directly relevant to unix systems.
The default is zero.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Mode">
      <summary>
 Get/set the entry's Unix style permission mode.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.TypeFlag">
      <summary>
 Get/set the entry's type flag.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.GroupId">
      <summary>
 Get/set the entry's group id.</summary>
      <remarks>

This is only directly relevant to linux/unix systems.
The default value is zero.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarHeader.Magic">
      <summary>
 Get/set the entry's magic tag.</summary>
      <exception cref="ArgumentNullException">
Thrown when attempting to set Magic to null.</exception>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarInputStream">
      <summary>
 The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read().</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.#ctor(System.IO.Stream)">
      <summary>
 Construct a TarInputStream with default block factor</summary>
      <param name="inputStream">
stream to source data from</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Construct a TarInputStream with user specified block factor</summary>
      <param name="inputStream">
stream to source data from</param>
      <param name="blockFactor">
block factor to apply to archive</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Flush">
      <summary>
 Flushes the baseInputStream</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 Set the streams position.  This operation is not supported and will throw a NotSupportedException</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.SetLength(System.Int64)">
      <summary>
 Sets the length of the stream This operation is not supported and will throw a NotSupportedException</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes a block of bytes to this stream using data from a buffer. This operation is not supported and will throw a NotSupportedException</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.WriteByte(System.Byte)">
      <summary>
 Writes a byte to the current position in the file stream. This operation is not supported and will throw a NotSupportedException</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.ReadByte">
      <summary>
 Reads a byte from the current tar archive entry. This method simply calls Read(byte[], int, int).</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Reads bytes from the current tar archive entry.  This method is aware of the boundaries of the current entry in the archive and will deal with them appropriately</summary>
      <returns>

The number of bytes read, or 0 at end of stream/EOF.
</returns>
      <param name="buffer">

The buffer into which to place bytes read.
</param>
      <param name="offset">

The offset at which to place bytes read.
</param>
      <param name="count">

The number of bytes to read.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Close">
      <summary>
 Closes this stream. Calls the TarBuffer's close() method. The underlying stream is closed by the TarBuffer.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.SetEntryFactory(ICSharpCode.SharpZipLib.Tar.TarInputStream.IEntryFactory)">
      <summary>
 Set the entry factory for this instance.</summary>
      <param name="factory">
The factory for creating new entries</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.GetRecordSize">
      <summary>
 Get the record size being used by this stream's TarBuffer.</summary>
      <returns>

TarBuffer record size.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Skip(System.Int64)">
      <summary>
 Skip bytes in the input buffer. This skips bytes in the current entry's data, not the entire archive, and will stop at the end of the current entry's data if the number to skip extends beyond that point.</summary>
      <param name="skipCount">

The number of bytes to skip.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Mark(System.Int32)">
      <summary>
 Since we do not support marking just yet, we do nothing.</summary>
      <param name="markLimit">

The limit to mark.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.Reset">
      <summary>
 Since we do not support marking just yet, we do nothing.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.GetNextEntry">
      <summary>
 Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.</summary>
      <returns>

The next TarEntry in the archive, or null.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.CopyEntryContents(System.IO.Stream)">
      <summary>
 Copies the contents of the current tar archive entry directly into an output stream.</summary>
      <param name="outputStream">

The OutputStream into which to write the entry's data.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.IEntryFactory.CreateEntry(System.String)">
      <summary>
 Create an entry based on name alone</summary>
      <returns>
created TarEntry or descendant class</returns>
      <param name="name">

Name of the new EntryPointNotFoundException to create
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.IEntryFactory.CreateEntryFromFile(System.String)">
      <summary>
 Create an instance based on an actual file</summary>
      <returns>

Created TarEntry or descendant class
</returns>
      <param name="fileName">

Name of file to represent in the entry
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.IEntryFactory.CreateEntry(System.Byte[])">
      <summary>
 Create a tar entry based on the header information passed</summary>
      <returns>

Created TarEntry or descendant class
</returns>
      <param name="headerBuf">

Buffer containing header information to base entry on
</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarInputStream.EntryFactoryAdapter">
      <summary>
 Standard entry factory class creating instances of the class TarEntry</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.EntryFactoryAdapter.CreateEntry(System.String)">
      <summary>
 Create a TarEntry based on named</summary>
      <param name="name">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.EntryFactoryAdapter.CreateEntryFromFile(System.String)">
      <summary>
 Create a tar entry with details obtained from <paramref name="fileName">file</paramref></summary>
      <param name="fileName">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarInputStream.EntryFactoryAdapter.CreateEntry(System.Byte[])">
      <summary>
 Create and entry based on details in <paramref name="headerBuf">header</paramref></summary>
      <param name="headerBuf">
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.CanWrite">
      <summary>
 Gets a value indicating if the stream supports writing. This property always returns false.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.CanSeek">
      <summary>
 Gets a value indicating whether the current stream supports seeking This property always returns false.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.IsMarkSupported">
      <summary>
 Return a value of true if marking is supported; false otherwise.</summary>
      <remarks>
Currently marking is not supported, the return value is always false.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.Length">
      <summary>
 The length in bytes of the stream</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.CanRead">
      <summary>
 Gets a value indicating whether the current stream supports reading</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.Available">
      <summary>
 Get the available data that can be read from the current entry in the archive. This does not indicate how much data is left in the entire archive, only in the current entry. This value is determined from the entry's size header field and the amount of data already read from the current entry.</summary>
      <value>

The number of available bytes for the current entry.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.RecordSize">
      <summary>
 Get the record size being used by this stream's TarBuffer.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarInputStream.Position">
      <summary>
 Gets or sets the position within the stream. Setting the Position is not supported and throws a NotSupportedExceptionNotSupportedException</summary>
      <exception cref="NotSupportedException">
Any attempt to set position</exception>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Tar.TarOutputStream">
      <summary>
 The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write().</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.#ctor(System.IO.Stream)">
      <summary>
 Construct TarOutputStream using default block factor</summary>
      <param name="outputStream">
stream to write to</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Construct TarOutputStream with user specified block factor</summary>
      <param name="outputStream">
stream to write to</param>
      <param name="blockFactor">
blocking factor</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 set the position within the current stream</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.SetLength(System.Int64)">
      <summary>
 set the length of the current stream</summary>
      <param name="value">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.ReadByte">
      <summary>
 Read a byte from the stream and advance the position within the stream by one byte or returns -1 if at the end of the stream.</summary>
      <returns>
The byte value or -1 if at end of stream</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 read bytes from the current stream and advance the position within the stream by the number of bytes read.</summary>
      <returns>
The total number of bytes read, or zero if at the end of the stream</returns>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Flush">
      <summary>
 All buffered data is written to destination</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Finish">
      <summary>
 Ends the TAR archive without closing the underlying OutputStream. The result is that the EOF block of nulls is written.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Close">
      <summary>
 Ends the TAR archive and closes the underlying OutputStream.</summary>
      <remarks>
This means that Finish() is called followed by calling the
TarBuffer's Close().</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.GetRecordSize">
      <summary>
 Get the record size being used by this stream's TarBuffer.</summary>
      <returns>

The TarBuffer record size.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.PutNextEntry(ICSharpCode.SharpZipLib.Tar.TarEntry)">
      <summary>
 Put an entry on the output stream. This writes the entry's header and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry's contents. Once the contents are written, closeEntry() <B>MUST</B> be called to ensure that all buffered data is completely written to the output stream.</summary>
      <param name="entry">

The TarEntry to be written to the archive.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.CloseEntry">
      <summary>
 Close an entry. This method MUST be called for all file entries that contain data. The reason is that we must buffer data written to the stream in order to satisfy the buffer's block based writes. Thus, there may be data fragments still being assembled that must be written to the output stream before this entry is closed and the next entry written.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.WriteByte(System.Byte)">
      <summary>
 Writes a byte to the current tar archive entry. This method simply calls Write(byte[], int, int).</summary>
      <param name="value">

The byte to be written.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by TarBuffer, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.</summary>
      <param name="buffer">

The buffer to write to the archive.
</param>
      <param name="offset">

The offset in the buffer from which to get bytes.
</param>
      <param name="count">

The number of bytes to write.
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Length">
      <summary>
 length of stream in bytes</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanRead">
      <summary>
 true if the stream supports reading; otherwise, false.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanSeek">
      <summary>
 true if the stream supports seeking; otherwise, false.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanWrite">
      <summary>
 true if stream supports writing; otherwise, false.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.RecordSize">
      <summary>
 Get the record size being used by this stream's TarBuffer.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Tar.TarOutputStream.Position">
      <summary>
 gets or sets the position within the current stream.</summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Zip.Compression">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">
      <summary>
 This is the Deflater class.  The deflater class compresses input with the deflate algorithm described in RFC 1951.  It has several compression levels and three different strategies described below.  This class is <i>not</i> thread safe.  This is inherent in the API, due to the split of deflate and setInput.  author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor">
      <summary>
 Creates a new deflater with default compression level.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
      <summary>
 Creates a new deflater with given compression level.</summary>
      <param name="level">

the compression level, a value between NO_COMPRESSION
and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
</param>
      <exception cref="System.ArgumentOutOfRangeException">
if lvl is out of range.</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
      <summary>
 Creates a new deflater with given compression level.</summary>
      <param name="level">

the compression level, a value between NO_COMPRESSION
and BEST_COMPRESSION.
</param>
      <param name="noZlibHeaderOrFooter">

true, if we should suppress the Zlib/RFC1950 header at the
beginning and the adler checksum at the end of the output.  This is
useful for the GZIP/PKZIP formats.
</param>
      <exception cref="System.ArgumentOutOfRangeException">
if lvl is out of range.</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset">
      <summary>
 Resets the deflater.  The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush">
      <summary>
 Flushes the current input block.  Further calls to deflate() will produce enough output to inflate everything in the current input block.  This is not part of Sun's JDK so I have made it package private.  It is used by DeflaterOutputStream to implement flush().</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish">
      <summary>
 Finishes the deflater with the current input block.  It is an error to give more input after this method was called.  This method must be called to force all bytes to be flushed.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
      <summary>
 Sets the data which should be compressed next.  This should be only called when needsInput indicates that more input is needed. If you call setInput when needsInput() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needsInput() returns true again. This call is equivalent to <code>setInput(input, 0, input.length)</code>.</summary>
      <param name="input">

the buffer containing the input data.
</param>
      <exception cref="System.InvalidOperationException">

if the buffer was finished() or ended().
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Sets the data which should be compressed next.  This should be only called when needsInput indicates that more input is needed. The given byte array should not be changed, before needsInput() returns true again.</summary>
      <param name="input">

the buffer containing the input data.
</param>
      <param name="offset">

the start of the data.
</param>
      <param name="count">

the number of data bytes of input.
</param>
      <exception cref="System.InvalidOperationException">

if the buffer was Finish()ed or if previous input is still pending.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
      <summary>
 Sets the compression level.  There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input.</summary>
      <param name="level">

the new compression level.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel">
      <summary>
 Get current compression level</summary>
      <returns>
Returns the current compression level</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy)">
      <summary>
 Sets the compression strategy. Strategy is one of DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact position where the strategy is changed, the same as for SetLevel() applies.</summary>
      <param name="strategy">

The new compression strategy.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
      <summary>
 Deflates the current input block with to the given array.</summary>
      <returns>

The number of compressed bytes added to the output, or 0 if either
IsNeedingInput() or IsFinished returns true or length is zero.
</returns>
      <param name="output">

The buffer where compressed data is stored
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Deflates the current input block to the given array.</summary>
      <returns>

The number of compressed bytes added to the output, or 0 if either
needsInput() or finished() returns true or length is zero.
</returns>
      <param name="output">

Buffer to store the compressed data.
</param>
      <param name="offset">

Offset into the output array.
</param>
      <param name="length">

The maximum number of bytes that may be stored.
</param>
      <exception cref="System.InvalidOperationException">

If Finish() was previously called.
</exception>
      <exception cref="System.ArgumentOutOfRangeException">

If offset or length don't match the array length.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
      <summary>
 Sets the dictionary which should be used in the deflate process. This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.</summary>
      <param name="dictionary">

the dictionary.
</param>
      <exception cref="System.InvalidOperationException">

if SetInput () or Deflate () were already called or another dictionary was already set.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed.  The dictionary is not stored in the compressed output, only a checksum.  To decompress the output you need to supply the same dictionary again.</summary>
      <param name="dictionary">

The dictionary data
</param>
      <param name="index">

The index where dictionary information commences.
</param>
      <param name="count">

The number of bytes in the dictionary.
</param>
      <exception cref="System.InvalidOperationException">

If SetInput () or Deflate() were already called or another dictionary was already set.
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsFinished">
      <summary>
 Returns true if the stream was finished and no more output bytes are available.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalIn">
      <summary>
 Gets the number of input bytes processed so far.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalOut">
      <summary>
 Gets the number of output bytes so far.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Adler">
      <summary>
 Gets the current adler checksum of the data that was processed so far.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
      <summary>
 Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method can also return true when the stream was finished.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants">
      <summary>
 This class contains constants used for deflation.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine">
      <summary>
 Low level compression engine for deflate algorithm which uses a 32K sliding window with secondary compression from Huffman/Shannon-Fano codes.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
      <summary>
 Construct instance with pending buffer</summary>
      <param name="pending">

Pending buffer to use
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
      <summary>
 Deflate drives actual compression of data</summary>
      <returns>
Returns true if progress has been made.</returns>
      <param name="flush">
</param>
      <param name="finish">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code> returns true</summary>
      <param name="buffer">
The buffer containing input data.</param>
      <param name="offset">
The offset of the first byte of data.</param>
      <param name="count">
The number of bytes of data to use as input.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
      <summary>
 Return true if input is needed via <see cref="SetInput"> SetInput</see></summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Set compression dictionary</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="length">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
      <summary>
 Reset internal state</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
      <summary>
 Reset Adler checksum</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
      <summary>
 Set the deflate level (0-9)</summary>
      <param name="level">
The value to set the level to.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
      <summary>
 Fill the window</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
      <summary>
 Get current value of Adler checksum</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
      <summary>
 Total data processed</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
      <summary>
 Get/set the <see cref="DeflateStrategy">deflate strategy</see></summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman">
      <summary>
 This is the DeflaterHuffman class.  This class is <i>not</i> thread safe.  This is inherent in the API, due to the split of Deflate and SetInput.  author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
      <summary>
 Construct instance with pending buffer</summary>
      <param name="pending">
Pending buffer to use</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
      <summary>
 Reset internal state</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
      <summary>
 Write all trees to pending buffer</summary>
      <param name="blTreeCodes">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
      <summary>
 Compress current buffer writing data to pending buffer</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
 Flush block to output with no compression</summary>
      <param name="stored">
Data to write</param>
      <param name="storedOffset">
Index of first byte to write</param>
      <param name="storedLength">
Count of bytes to write</param>
      <param name="lastBlock">
True if this is the last block</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
 Flush block to output with compression</summary>
      <param name="stored">
Data to flush</param>
      <param name="storedOffset">
Index of first byte to flush</param>
      <param name="storedLength">
Count of bytes to flush</param>
      <param name="lastBlock">
True if this is the last block</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
      <summary>
 Get value indicating if internal buffer is full</summary>
      <returns>
true if buffer is full</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
      <summary>
 Add literal to buffer</summary>
      <returns>
Value indicating internal buffer is full</returns>
      <param name="literal">
Literal value to add to buffer.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
      <summary>
 Add distance code and length to literal and distance trees</summary>
      <returns>
Value indicating if internal buffer is full</returns>
      <param name="distance">
Distance code</param>
      <param name="length">
Length</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
      <summary>
 Reverse the bits of a 16 bit value.</summary>
      <returns>
Value with bits reversed</returns>
      <param name="toReverse">
Value to reverse bits</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending">
      <summary>
 This class stores the pending output of the Deflater.  author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
      <summary>
 Construct instance with default buffer size</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Inflater">
      <summary>
 Inflater is used to decompress data that has been compressed according to the "deflate" standard described in rfc1951.  By default Zlib (rfc1950) headers and footers are expected in the input. You can use constructor <code> public Inflater(bool noHeader)</code> passing true if there is no Zlib header information  The usage is as following.  First you have to set some input with <code>SetInput()</code>, then Inflate() it.  If inflate doesn't inflate any bytes there may be three reasons: <ul> <li>IsNeedingInput() returns true because the input buffer is empty. You have to provide more input with <code>SetInput()</code>. NOTE: IsNeedingInput() also returns true when, the stream is finished. </li> <li>IsNeedingDictionary() returns true, you have to provide a preset    dictionary with <code>SetDictionary()</code>.</li> <li>IsFinished returns true, the inflater has finished.</li> </ul> Once the first output byte is produced, a dictionary will not be needed at a later stage.  author of the original java version : John Leuner, Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor">
      <summary>
 Creates a new inflater or RFC1951 decompressor RFC1950/Zlib headers and footers will be expected in the input data</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
      <summary>
 Creates a new inflater.</summary>
      <param name="noHeader">

True if no RFC1950/Zlib header and footer fields are expected in the input data

This is used for GZIPed/Zipped input.

For compatibility with
Sun JDK you should provide one byte of input more than needed in
this case.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Reset">
      <summary>
 Resets the inflater so that a new stream can be decompressed.  All pending input and output will be discarded.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
      <summary>
 Sets the preset dictionary.  This should only be called, if needsDictionary() returns true and it should set the same dictionary, that was used for deflating.  The getAdler() function returns the checksum of the dictionary needed.</summary>
      <param name="buffer">

The dictionary.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Sets the preset dictionary.  This should only be called, if needsDictionary() returns true and it should set the same dictionary, that was used for deflating.  The getAdler() function returns the checksum of the dictionary needed.</summary>
      <param name="buffer">

The dictionary.
</param>
      <param name="index">

The index into buffer where the dictionary starts.
</param>
      <param name="count">

The number of bytes in the dictionary.
</param>
      <exception cref="System.InvalidOperationException">

No dictionary is needed.
</exception>
      <exception cref="SharpZipBaseException">

The adler checksum for the buffer is invalid
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
      <summary>
 Sets the input.  This should only be called, if needsInput() returns true.</summary>
      <param name="buffer">

the input.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Sets the input.  This should only be called, if needsInput() returns true.</summary>
      <param name="buffer">

The source of input data
</param>
      <param name="index">

The index into buffer where the input starts.
</param>
      <param name="count">

The number of bytes of input to use.
</param>
      <exception cref="System.InvalidOperationException">

No input is needed.
</exception>
      <exception cref="System.ArgumentOutOfRangeException">

The index and/or count are wrong.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
      <summary>
 Inflates the compressed stream to the output buffer.  If this returns 0, you should check, whether IsNeedingDictionary(), IsNeedingInput() or IsFinished() returns true, to determine why no further output is produced.</summary>
      <returns>

The number of bytes written to the buffer, 0 if no further
output can be produced.
</returns>
      <param name="buffer">

the output buffer.
</param>
      <exception cref="System.ArgumentOutOfRangeException">

if buffer has length 0.
</exception>
      <exception cref="System.FormatException">

if deflated stream is invalid.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Inflates the compressed stream to the output buffer.  If this returns 0, you should check, whether needsDictionary(), needsInput() or finished() returns true, to determine why no further output is produced.</summary>
      <returns>

the number of bytes written to the buffer, 0 if no further output can be produced.
</returns>
      <param name="buffer">

the output buffer.
</param>
      <param name="offset">

the offset in buffer where storing starts.
</param>
      <param name="count">

the maximum number of bytes to output.
</param>
      <exception cref="System.ArgumentOutOfRangeException">

if count is less than 0.
</exception>
      <exception cref="System.ArgumentOutOfRangeException">

if the index and / or count are wrong.
</exception>
      <exception cref="System.FormatException">

if deflated stream is invalid.
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
      <summary>
 Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method also returns true when the stream is finished.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
      <summary>
 Gets the number of unprocessed input bytes.  Useful, if the end of the stream is reached and you want to further process the bytes after the deflate stream.</summary>
      <value>

The number of bytes of the input which have not been processed.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalOut">
      <summary>
 Gets the total number of output bytes returned by Inflate().</summary>
      <value>

the total number of output bytes.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Adler">
      <summary>
 Gets the adler checksum.  This is either the checksum of all uncompressed bytes returned by inflate(), or if needsDictionary() returns true (and thus no output was yet produced) this is the adler checksum of the expected dictionary.</summary>
      <value>

the adler checksum.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsFinished">
      <summary>
 Returns true, if the inflater has finished.  This means, that no input is needed and no output can be produced.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
      <summary>
 Returns true, if a preset dictionary is needed to inflate the input.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalIn">
      <summary>
 Gets the total number of processed compressed input bytes.</summary>
      <value>

The total number of bytes of processed input bytes.
</value>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
      <summary>
 Huffman tree used for inflation</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
      <summary>
 Constructs a Huffman tree from the array of code lengths.</summary>
      <param name="codeLengths">

the array of code lengths
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
      <summary>
 Reads the next symbol from input.  The symbol is encoded using the huffman tree.</summary>
      <returns>

the next symbol, or -1 if not enough input is available.
</returns>
      <param name="input">

input the input source.
</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer">
      <summary>
 This class is general purpose class for writing data to a buffer.  It allows you to write bits as well as bytes Based on DeflaterPending.java  author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
      <summary>
 construct instance using default buffer size of 4096</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
      <summary>
 construct instance using specified buffer size</summary>
      <param name="bufferSize">

size to use for internal buffer
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
      <summary>
 Clear internal state/buffers</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
      <summary>
 Write a byte to buffer</summary>
      <param name="value">

The value to write
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
      <summary>
 Write a short value to buffer LSB first</summary>
      <param name="value">

The value to write.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
      <summary>
 write an integer LSB first</summary>
      <param name="value">
The value to write.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Write a block of data to buffer</summary>
      <param name="block">
data to write</param>
      <param name="offset">
offset of first byte to write</param>
      <param name="length">
number of bytes to write</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
      <summary>
 Align internal buffer on a byte boundary</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
      <summary>
 Write bits to internal buffer</summary>
      <param name="b">
source of bits</param>
      <param name="count">
number of bits to write</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
      <summary>
 Write a short value to internal buffer most significant byte first</summary>
      <param name="s">
value to write</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Flushes the pending buffer into the given output array.  If the output array is to small, only a partial flush is done.</summary>
      <param name="output">

The output array.
</param>
      <param name="offset">

The offset into output array.
</param>
      <param name="length">

The maximum number of bytes to store.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
      <summary>
 Convert internal buffer to byte array. Buffer is empty on completion</summary>
      <returns>

The internal buffer contents converted to a byte array.
</returns>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
      <summary>
 Indicates if buffer has been flushed</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
      <summary>
 The number of bits written to the buffer</summary>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Zip.Compression.Streams">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
      <summary>
 A special stream deflating or compressing the bytes that are written to it.  It uses a Deflater to perform actual deflating.<br /> Authors of the original java version : Tom Tromey, Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
      <summary>
 Creates a new DeflaterOutputStream with a default Deflater and default buffer size.</summary>
      <param name="baseOutputStream">

the output stream where deflated output should be written.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater)">
      <summary>
 Creates a new DeflaterOutputStream with the given Deflater and default buffer size.</summary>
      <param name="baseOutputStream">

the output stream where deflated output should be written.
</param>
      <param name="deflater">

the underlying deflater.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
      <summary>
 Creates a new DeflaterOutputStream with the given Deflater and buffer size.</summary>
      <param name="baseOutputStream">

The output stream where deflated output is written.
</param>
      <param name="deflater">

The underlying deflater to use
</param>
      <param name="bufferSize">

The buffer size to use when deflating
</param>
      <exception cref="ArgumentOutOfRangeException">

bufsize is less than or equal to zero.
</exception>
      <exception cref="ArgumentException">

baseOutputStream does not support writing
</exception>
      <exception cref="ArgumentNullException">

deflater instance is null
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
      <summary>
 Finishes the stream by calling finish() on the deflater.</summary>
      <exception cref="SharpZipBaseException">

Not all input is deflated
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 Sets the current position of this stream to the given value. Not supported by this class!</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
      <summary>
 Sets the length of this stream to the given value. Not supported by this class!</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
      <summary>
 Read a byte from stream advancing position by one</summary>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read a block of bytes from stream</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
 Asynchronous reads are not supported a NotSupportedException is always thrown</summary>
      <returns>
Returns an <see cref="IAsyncResult" /></returns>
      <param name="buffer">
The buffer to read into.</param>
      <param name="offset">
The offset to start storing data at.</param>
      <param name="count">
The number of bytes to read</param>
      <param name="callback">
The async callback to use.</param>
      <param name="state">
The state to use.</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
 Asynchronous writes arent supported, a NotSupportedException is always thrown</summary>
      <returns>
Returns an IAsyncResult.</returns>
      <param name="buffer">
The buffer to write.</param>
      <param name="offset">
The offset to begin writing at.</param>
      <param name="count">
The number of bytes to write.</param>
      <param name="callback">
The <see cref="AsyncCallback" /> to use.</param>
      <param name="state">
The state object.</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
      <summary>
 Flushes the stream by calling flush() on the deflater and then on the underlying stream.  This ensures that all bytes are flushed.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
      <summary>
 Calls <see cref="Finish" /> and closes the underlying stream when <see cref="IsStreamOwner"></see> is true.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
      <summary>
 Writes a single byte to the compressed output stream.</summary>
      <param name="value">

The byte value.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes bytes from an array to the compressed stream.</summary>
      <param name="buffer">

The byte array
</param>
      <param name="offset">

The offset into the byte array where to start.
</param>
      <param name="count">

The number of bytes to write.
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
      <summary>
 Get/set flag indicating ownership of the underlying stream. When the flag is true <see cref="Close"></see> will close the underlying stream also.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
      <summary>
 Gets a value indicating if seeking is supported for this stream This property always returns false</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
      <summary>
 Get value indicating if this stream supports writing</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
      <summary>
 Allows client to determine if an entry can be patched after its added</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
      <summary>
 Gets the current position within the stream.</summary>
      <exception cref="NotSupportedException">
Any attempt to set position</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
      <summary>
 Get/set the password used for encryption.</summary>
      <remarks>
When set to null or if the password is empty no encryption is performed</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
      <summary>
 Get current length of stream</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
      <summary>
 Gets value indicating stream can be read from</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
      <summary>
 An input buffer customised for use by <see cref="InflaterInputStream" /></summary>
      <remarks>

The buffer supports decryption of incoming data.
</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
      <summary>
 Initialise a new instance of <see cref="InflaterInputBuffer" /> with a default buffer size</summary>
      <param name="stream">
The stream to buffer.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
      <summary>
 Initialise a new instance of <see cref="InflaterInputBuffer" /></summary>
      <remarks>
A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
      <param name="stream">
The stream to buffer.</param>
      <param name="bufferSize">
The size to use for the buffer</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
      <summary>
 Call <see cref="Inflater.SetInput(byte[], int, int)" /> passing the current clear text buffer contents.</summary>
      <param name="inflater">
The inflater to set input for.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
      <summary>
 Fill the buffer from the underlying input stream.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
      <summary>
 Read a buffer directly from the input stream</summary>
      <returns>
Returns the number of bytes read.</returns>
      <param name="buffer">
The buffer to fill</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read a buffer directly from the input stream</summary>
      <returns>
Returns the number of bytes read.</returns>
      <param name="outBuffer">
The buffer to read into</param>
      <param name="offset">
The offset to start reading data into.</param>
      <param name="length">
The number of bytes to read.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read clear text data from the input stream.</summary>
      <returns>
Returns the number of bytes actually read.</returns>
      <param name="outBuffer">
The buffer to add data to.</param>
      <param name="offset">
The offset to start adding data at.</param>
      <param name="length">
The number of bytes to read.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
      <summary>
 Read a byte from the input stream.</summary>
      <returns>
Returns the byte read.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
      <summary>
 Read an unsigned short in little endian byte order.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
      <summary>
 Read an int in little endian byte order.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
      <summary>
 Read an int baseInputStream little endian byte order.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
      <summary>
 Get the length of bytes bytes in the <see cref="RawData" /></summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
      <summary>
 Get the contents of the clear text buffer.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
      <summary>
 Get the number of useable bytes in <see cref="ClearText" /></summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
      <summary>
 Get/set the number of bytes available</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
      <summary>
 Get the contents of the raw data buffer.</summary>
      <remarks>
This may contain encrypted data.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
      <summary>
 Get/set the <see cref="ICryptoTransform" /> to apply to any data.</summary>
      <remarks>
Set this value to null to have no transform applied.</remarks>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
      <summary>
 This filter stream is used to decompress data compressed using the "deflate" format. The "deflate" format is described in RFC 1951.  This stream may form the basis for other decompression filters, such as the <see cref="ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.  Author of the original java version : John Leuner.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
      <summary>
 Create an InflaterInputStream with the default decompressor and a default buffer size of 4KB.</summary>
      <param name="baseInputStream">

The InputStream to read bytes from
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
      <summary>
 Create an InflaterInputStream with the specified decompressor and a default buffer size of 4KB.</summary>
      <param name="baseInputStream">

The source of input data
</param>
      <param name="inf">

The decompressor used to decompress data read from baseInputStream
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
      <summary>
 Create an InflaterInputStream with the specified decompressor and the specified buffer size.</summary>
      <param name="baseInputStream">

The InputStream to read bytes from
</param>
      <param name="inflater">

The decompressor to use
</param>
      <param name="bufferSize">

Size of the buffer to use
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
      <summary>
 Skip specified number of bytes of uncompressed data</summary>
      <returns>

The number of bytes skipped, zero if the end of
stream has been reached
</returns>
      <param name="count">

Number of bytes to skip
</param>
      <exception cref="ArgumentOutOfRangeException">

Number of bytes to skip is less than zero
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
      <summary>
 Flushes the baseInputStream</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
 Sets the position within the current stream Always throws a NotSupportedException</summary>
      <param name="offset">
</param>
      <param name="origin">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
      <summary>
 Set the length of the current stream Always throws a NotSupportedException</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes a sequence of bytes to stream and advances the current position This method always throws a NotSupportedException</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
      <summary>
 Writes one byte to the current stream and advances the current position Always throws a NotSupportedException</summary>
      <param name="value">
</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
 Entry point to begin an asynchronous write.  Always throws a NotSupportedException.</summary>
      <returns>
An <see cref="System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
      <param name="buffer">
The buffer to write data from</param>
      <param name="offset">
Offset of first byte to write</param>
      <param name="count">
The maximum number of bytes to write</param>
      <param name="callback">
The method to be called when the asynchronous write operation is completed</param>
      <param name="state">
A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
      <exception cref="NotSupportedException">
Any access</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
      <summary>
 Closes the input stream.  When <see cref="IsStreamOwner"></see> is true the underlying stream is also closed.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Reads decompressed data into the provided buffer byte array</summary>
      <returns>
The number of bytes read.  Zero signals the end of stream</returns>
      <param name="buffer">

The array to read and decompress data into
</param>
      <param name="offset">

The offset indicating where the data should be placed
</param>
      <param name="count">

The number of bytes to decompress
</param>
      <exception cref="SharpZipBaseException">

Inflater needs a dictionary
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
      <summary>
 Get/set flag indicating ownership of underlying stream. When the flag is true <see cref="Close" /> will close the underlying stream also.</summary>
      <remarks>

The default value is true.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
      <summary>
 Gets a value indicating whether the current stream supports reading</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
      <summary>
 A value representing the length of the stream in bytes.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
      <summary>
 Gets a value of false indicating seeking is not supported for this stream.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
      <summary>
 The current position within the stream. Throws a NotSupportedException when attempting to set the position</summary>
      <exception cref="NotSupportedException">
Attempting to set the position</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
      <summary>
 Returns 0 once the end of the stream (EOF) has been reached. Otherwise returns 1.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
      <summary>
 Gets a value of false indicating that this stream is not writeable.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow">
      <summary>
 Contains the output from the Inflation process. We need to have a window so that we can refer backwards into the output stream to repeat stuff.<br /> Author of the original java version : John Leuner</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
      <summary>
 Write a byte to this output window</summary>
      <param name="value">
value to write</param>
      <exception cref="InvalidOperationException">

if window is full
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
      <summary>
 Append a byte pattern already in the window itself</summary>
      <param name="length">
length of pattern to copy</param>
      <param name="distance">
distance from end of window pattern occurs</param>
      <exception cref="InvalidOperationException">

If the repeated data overflows the window
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
      <summary>
 Copy from input manipulator to internal window</summary>
      <returns>
the number of bytes copied</returns>
      <param name="input">
source of data</param>
      <param name="length">
length of data to copy</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Copy dictionary to window</summary>
      <param name="dictionary">
source dictionary</param>
      <param name="offset">
offset of start in source dictionary</param>
      <param name="length">
length of dictionary</param>
      <exception cref="InvalidOperationException">

If window isnt empty
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
      <summary>
 Get remaining unfilled space in window</summary>
      <returns>
Number of bytes left in window</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
      <summary>
 Get bytes available for output in window</summary>
      <returns>
Number of bytes filled</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Copy contents of window to output</summary>
      <returns>
The number of bytes copied</returns>
      <param name="output">
buffer to copy to</param>
      <param name="offset">
offset to start at</param>
      <param name="len">
number of bytes to count</param>
      <exception cref="InvalidOperationException">

If a window underflow occurs
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
      <summary>
 Reset by clearing window so <see cref="GetAvailable">GetAvailable</see> returns 0</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
      <summary>
 This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks.  It uses an int buffer to store up to 31 bits for direct manipulation.  This guarantees that we can get at least 16 bits, but we only need at most 15, so this is all safe.  There are some optimizations in this class, for example, you must never peek more than 8 bits more than needed, and you must first peek bits before you may drop them.  This is not a general purpose class but optimized for the behaviour of the Inflater.  authors of the original java version : John Leuner, Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
      <summary>
 Constructs a default StreamManipulator with all buffers empty</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
      <summary>
 Get the next sequence of bits but don't increase input pointer.  bitCount must be less or equal 16 and if this call succeeds, you must drop at least n - 8 bits in the next call.</summary>
      <returns>

the value of the bits, or -1 if not enough bits available.  */
</returns>
      <param name="bitCount">
The number of bits to peek.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
      <summary>
 Drops the next n bits from the input.  You should have called PeekBits with a bigger or equal n before, to make sure that enough bits are in the bit buffer.</summary>
      <param name="bitCount">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
      <summary>
 Gets the next n bits and increases input pointer.  This is equivalent to <see cref="PeekBits" /> followed by <see cref="DropBits" />, except for correct error handling.</summary>
      <returns>

the value of the bits, or -1 if not enough bits available.
</returns>
      <param name="bitCount">
The number of bits to retrieve.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
      <summary>
 Skips to the next byte boundary.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Copies bytes from input buffer to output buffer starting at output[offset].  You have to make sure, that the buffer is byte aligned.  If not enough bytes are available, copies fewer bytes.</summary>
      <returns>

The number of bytes copied, 0 if no bytes were available.
</returns>
      <param name="output">

The buffer to copy bytes to.
</param>
      <param name="offset">

The offset in the buffer at which copying starts
</param>
      <param name="length">

The length to copy, 0 is allowed.
</param>
      <exception cref="ArgumentOutOfRangeException">

Length is less than zero
</exception>
      <exception cref="InvalidOperationException">

Bit buffer isnt byte aligned
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
      <summary>
 Resets state and empties internal buffers</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Add more input for consumption. Only call when IsNeedingInput returns true</summary>
      <param name="buffer">
data to be input</param>
      <param name="offset">
offset of first byte of input</param>
      <param name="count">
number of bytes of input to add.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
      <summary>
 Returns true when SetInput can be called</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
      <summary>
 Gets the number of bits available in the bit buffer.  This must be only called when a previous PeekBits() returned -1.</summary>
      <value>

the number of bits available.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
      <summary>
 Gets the number of bytes available.</summary>
      <value>

The number of bytes available.
</value>
</member>
    <member name="N:ICSharpCode.SharpZipLib.Zip">
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZipEvents">
      <summary>
 FastZipEvents supports all events applicable to <see cref="FastZip">FastZip</see> operations.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnDirectoryFailure(System.String,System.Exception)">
      <summary>
 Raise the <see cref="DirectoryFailure">directory failure</see> event.</summary>
      <returns>
A boolean indicating if execution should continue or not.</returns>
      <param name="directory">
The directory causing the failure.</param>
      <param name="e">
The exception for this event.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnFileFailure(System.String,System.Exception)">
      <summary>
 Raises the <see cref="FileFailure">file failure delegate</see>.</summary>
      <returns>
A boolean indicating if execution should continue or not.</returns>
      <param name="file">
The file causing the failure.</param>
      <param name="e">
The exception for this failure.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnProcessFile(System.String)">
      <summary>
 Raises the <see cref="ProcessFile">Process File delegate</see>.</summary>
      <returns>
A boolean indicating if execution should continue or not.</returns>
      <param name="file">
The file being processed.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZipEvents.OnProcessDirectory(System.String,System.Boolean)">
      <summary>
 Fires the <see cref="ProcessDirectory">process directory</see> delegate.</summary>
      <param name="directory">
The directory being processed.</param>
      <param name="hasMatchingFiles">
Flag indicating if directory has matching files as determined by the current filter.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.FastZip">
      <summary>
 FastZip provides facilities for creating and extracting zip files. Only relative paths are supported.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.#ctor">
      <summary>
 Initialise a default instance of <see cref="FastZip" />.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.#ctor(ICSharpCode.SharpZipLib.Zip.FastZipEvents)">
      <summary>
 Initialise a new instance of <see cref="FastZip" /></summary>
      <param name="events">
The <see cref="FastZipEvents">events</see> to use during operations.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String,System.String)">
      <summary>
 Create a zip file.</summary>
      <param name="zipFileName">
The name of the zip file to create.</param>
      <param name="sourceDirectory">
The directory to source files from.</param>
      <param name="recurse">
True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">
The <see cref="PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">
The <see cref="PathFilter">directory filter</see> to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String)">
      <summary>
 Create a zip file/archive.</summary>
      <param name="zipFileName">
The name of the zip file to create.</param>
      <param name="sourceDirectory">
The directory to obtain files and directories from.</param>
      <param name="recurse">
True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">
The file filter to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.CreateZip(System.IO.Stream,System.String,System.Boolean,System.String,System.String)">
      <summary>
 Create a zip archive sending output to the <paramref name="outputStream" /> passed.</summary>
      <param name="outputStream">
The stream to write archive data to.</param>
      <param name="sourceDirectory">
The directory to source files from.</param>
      <param name="recurse">
True to recurse directories, false for no recursion.</param>
      <param name="fileFilter">
The <see cref="PathFilter">file filter</see> to apply.</param>
      <param name="directoryFilter">
The <see cref="PathFilter">directory filter</see> to apply.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,System.String)">
      <summary>
 Extract the contents of a zip file.</summary>
      <param name="zipFileName">
The zip file to extract from.</param>
      <param name="targetDirectory">
The directory to save extracted information in.</param>
      <param name="fileFilter">
A filter to apply to files.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,ICSharpCode.SharpZipLib.Zip.FastZip.Overwrite,ICSharpCode.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate,System.String,System.String,System.Boolean)">
      <summary>
 Extract the contents of a zip file.</summary>
      <param name="zipFileName">
The zip file to extract from.</param>
      <param name="targetDirectory">
The directory to save extracted information in.</param>
      <param name="overwrite">
The style of <see cref="Overwrite">overwriting</see> to apply.</param>
      <param name="confirmDelegate">
A delegate to invoke when confirming overwriting.</param>
      <param name="fileFilter">
A filter to apply to files.</param>
      <param name="directoryFilter">
A filter to apply to directories.</param>
      <param name="restoreDateTime">
Flag indicating wether to restore the date and time for extracted files.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.CreateEmptyDirectories">
      <summary>
 Get/set a value indicating wether empty directories should be created.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.EntryFactory">
      <summary>
 Get or set the <see cref="IEntryFactory"></see> active when creating Zip files.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.NameTransform">
      <summary>
 Get or set the <see cref="INameTransform"></see> active when creating Zip files.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.Password">
      <summary>
 Get / set the password value.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.FastZip.RestoreDateTimeOnExtract">
      <summary>
 Get/set a value indicating wether file dates and times should be restored when extracting files from an archive.</summary>
      <remarks>
The default value is false.</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String)">
      <summary>
 Create a <see cref="ZipEntry" /> for a file given its name</summary>
      <param name="fileName">
The name of the file to create an entry for.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String)">
      <summary>
 Create a <see cref="ZipEntry" /> for a directory given its name</summary>
      <param name="directoryName">
The name of the directory to create an entry for.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.IEntryFactory.NameTransform">
      <summary>
 Get/set the <see cref="INameTransform"></see> applicable.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">
      <summary>
 This class contains constants used for Zip format files</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
      <summary>
 Convert a portion of a byte array to a string.</summary>
      <returns>

data[0]..data[length - 1] converted to a string
</returns>
      <param name="data">

Data to convert to string
</param>
      <param name="count">

Number of bytes to convert starting from index 0
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
      <summary>
 Convert a byte array to string</summary>
      <returns>

<paramref name="data">data</paramref>converted to a string
</returns>
      <param name="data">

Byte array to convert
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
      <summary>
 Convert a byte array to string</summary>
      <returns>

<paramref name="data">data</paramref>converted to a string
</returns>
      <param name="flags">
The applicable general purpose bits flags</param>
      <param name="data">

Byte array to convert
</param>
      <param name="count">
The number of bytes to convert.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
      <summary>
 Convert a byte array to string</summary>
      <returns>

<paramref name="data">data</paramref>converted to a string
</returns>
      <param name="flags">
The applicable general purpose bits flags</param>
      <param name="data">

Byte array to convert
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
      <summary>
 Convert a string to a byte array</summary>
      <returns>
Converted array</returns>
      <param name="str">

String to convert to an array
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
      <summary>
 Convert a string to a byte array</summary>
      <returns>
Converted array</returns>
      <param name="flags">
The applicable general purpose bits flags</param>
      <param name="str">

String to convert to an array
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
      <summary>
 Default encoding used for string conversion.  0 gives the default system Ansi code page. Dont use unicode encodings if you want to be Zip compatible! Using the default code page isnt the full solution neccessarily there are many variable factors, codepage 850 is often a good choice for European users, however be careful about compatability.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">
      <summary>
 This class represents an entry in a zip archive.  This can be a file or a directory ZipFile and ZipInputStream will give you instances of this class as information about the members in an archive.  ZipOutputStream uses an instance of this class when creating an entry in a Zip file. <br /> <br />Author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
      <summary>
 Creates a zip entry with the given name.</summary>
      <param name="name">

The name for this entry. Can include directory components.
The convention for names is 'unix' style paths with relative names only.
There are with no device names and path elements are separated by '/' characters.
</param>
      <exception cref="ArgumentNullException">

The name passed is null
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
 Creates a deep copy of the given zip entry.</summary>
      <param name="entry">

The entry to copy.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64">
      <summary>
 Force this entry to be recorded using Zip64 extensions.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
      <summary>
 Get a value indicating wether Zip64 extensions were forced.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
      <summary>
 Test entry to see if data can be extracted.</summary>
      <returns>
Returns true if data can be extracted for this entry; false otherwise.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.Clone">
      <summary>
 Creates a copy of this zip entry.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ToString">
      <summary>
 Gets the string representation of this ZipEntry.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
 Test a <see cref="CompressionMethod">compression method</see> to see if this library supports extracting data compressed with that method</summary>
      <returns>
Returns true if the compression method is supported; false otherwise</returns>
      <param name="method">
The compression method to test.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
      <summary>
 Cleans a name making it conform to Zip file conventions. Devices names ('c:\') and UNC share names ('\\server\share') are removed and forward slashes ('\') are converted to back slashes ('/'). Names are made relative by trimming leading slashes which is compatible with the ZIP naming convention.</summary>
      <param name="name">
Name to clean</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress">
      <summary>
 Get a value indicating wether this entry can be decompressed by the library.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted">
      <summary>
 Get/Set flag indicating if entry is encrypted. A simple helper routine to aid interpretation of <see cref="Flags">flags</see></summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">
      <summary>
 Gets the compatability information for the <see cref="ExternalFileAttributes">external file attribute</see> If the external file attributes are compatible with MS-DOS and can be read by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value will be non-zero and identify the host system on which the attributes are compatible.</summary>
      <remarks>

The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
to obtain up to date and correct information.  The modified appnote by the infozip group is
particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
<list type="table">
<item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
<item>1 - Amiga</item>
<item>2 - OpenVMS</item>
<item>3 - Unix</item>
<item>4 - VM/CMS</item>
<item>5 - Atari ST</item>
<item>6 - OS/2 HPFS</item>
<item>7 - Macintosh</item>
<item>8 - Z-System</item>
<item>9 - CP/M</item>
<item>10 - Windows NTFS</item>
<item>11 - MVS (OS/390 - Z/OS)</item>
<item>12 - VSE</item>
<item>13 - Acorn Risc</item>
<item>14 - VFAT</item>
<item>15 - Alternate MVS</item>
<item>16 - BeOS</item>
<item>17 - Tandem</item>
<item>18 - OS/400</item>
<item>19 - OS/X (Darwin)</item>
<item>99 - WinZip AES</item>
<item>remainder - unused</item>
</list>
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasCrc">
      <summary>
 Get a value indicating wether the entry has a CRC value available.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressedSize">
      <summary>
 Gets/Sets the size of the compressed data.</summary>
      <value>

The compressed entry size or -1 if unknown.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime">
      <summary>
 Get/Set DosTime</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsFile">
      <summary>
 Get a value of true if the entry appears to be a file; false otherwise</summary>
      <remarks>

This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
For linux and others the result may be incorrect.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
      <summary>
 Get/Set external file attributes as an integer. The values of this are operating system dependant see <see cref="HostSystem">HostSystem</see> for details</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Name">
      <summary>
 Returns the entry name.  The path components in the entry should always separated by slashes ('/').  Dos device names like C: should also be removed.  See the <see cref="ZipNameTransform" /> class, or <see cref="CleanName(string)" /></summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">
      <summary>
 Gets/Sets the compression method. Only Deflated and Stored are supported.</summary>
      <value>

The compression method for this entry
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Comment">
      <summary>
 Gets/Sets the entry comment.</summary>
      <remarks>

A comment is only available for entries when read via the <see cref="ZipFile" /> class.
The <see cref="ZipInputStream" /> class doesnt have the comment data available.
</remarks>
      <value>

The comment or null if not set.
</value>
      <exception cref="System.ArgumentOutOfRangeException">

If comment is longer than 0xffff.
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDirectory">
      <summary>
 Gets a value indicating if the entry is a directory. however.</summary>
      <remarks>

A directory is determined by an entry name with a trailing slash '/'.
The external file attributes can also indicate an entry is for a directory.
Currently only dos/windows attributes are tested in this manner.
The trailing slash convention should always be followed.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Crc">
      <summary>
 Gets/Sets the crc of the uncompressed data.</summary>
      <value>

The crc value or -1 if unknown.
</value>
      <exception cref="System.ArgumentOutOfRangeException">

Crc is not in the range 0..0xffffffffL
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
      <summary>
 Get/Set index of this entry in Zip file</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version">
      <summary>
 Get minimum Zip feature version required to extract this entry</summary>
      <remarks>

Minimum features are defined as:<br />
1.0 - Default value<br />
1.1 - File is a volume label<br />
2.0 - File is a folder/directory<br />
2.0 - File is compressed using Deflate compression<br />
2.0 - File is encrypted using traditional encryption<br />
2.1 - File is compressed using Deflate64<br />
2.5 - File is compressed using PKWARE DCL Implode<br />
2.7 - File is a patch data set<br />
4.5 - File uses Zip64 format extensions<br />
4.6 - File is compressed using BZIP2 compression<br />
5.0 - File is encrypted using DES<br />
5.0 - File is encrypted using 3DES<br />
5.0 - File is encrypted using original RC2 encryption<br />
5.0 - File is encrypted using RC4 encryption<br />
5.1 - File is encrypted using AES encryption<br />
5.1 - File is encrypted using corrected RC2 encryption<br />
5.1 - File is encrypted using corrected RC2-64 encryption<br />
6.1 - File is encrypted using non-OAEP key wrapping<br />
6.2 - Central directory encryption (not confirmed yet)<br />
6.3 - File is compressed using LZMA<br />
6.3 - File is compressed using PPMD+<br />
6.3 - File is encrypted using Blowfish<br />
6.3 - File is encrypted using Twofish<br />
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
      <summary>
 Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
      <summary>
 Get / set a flag indicating wether entry name and comment text are encoded in Unicode UTF8</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime">
      <summary>
 Gets/Sets the time of last modification of the entry.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExtraData">
      <summary>
 Gets/Sets the extra data.</summary>
      <value>

Extra data or null if not set.
</value>
      <exception cref="System.ArgumentOutOfRangeException">

Extra data is longer than 64KB (0xffff) bytes.
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
      <summary>
 Gets a value indicating if the entry requires Zip64 extensions to store the full entry values.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
      <summary>
 Get the version made by for this entry or zero if unknown. The value / 10 indicates the major version number, and the value mod 10 is the minor version number</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Offset">
      <summary>
 Get/set offset for use in central header</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Size">
      <summary>
 Gets/Sets the size of the uncompressed data.</summary>
      <value>

The size or -1 if unknown.
</value>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">
      <summary>
 Get/Set general purpose bit flag for entry</summary>
      <remarks>

General purpose bit flag<br />
Bit 0: If set, indicates the file is encrypted<br />
Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br />
Imploding:<br />
Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br />
Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br />
<br />
Deflating:<br />
  Bit 2    Bit 1<br />
    0        0       Normal compression was used<br />
    0        1       Maximum compression was used<br />
    1        0       Fast compression was used<br />
    1        1       Super fast compression was used<br />
<br />
Bit 3: If set, the fields crc-32, compressed size
and uncompressed size are were not able to be written during zip file creation
The correct values are held in a data descriptor immediately following the compressed data. <br />
Bit 4: Reserved for use by PKZIP for enhanced deflating<br />
Bit 5: If set indicates the file contains compressed patch data<br />
Bit 6: If set indicates strong encryption was used.<br />
Bit 7-15: Unused or reserved<br />
</remarks>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipException">
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor">
      <summary>
 Initializes a new instance of the ZipException class.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String)">
      <summary>
 Initializes a new instance of the ZipException class with a specified error message.</summary>
      <param name="message">
The error message that explains the reason for the exception.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
      <summary>
 Initialise a new instance of ZipException.</summary>
      <param name="message">
A message describing the error.</param>
      <param name="exception">
The exception that is the cause of the current exception.</param>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipExtraData">
      <summary>
 A class to handle the extra data field for Zip entries</summary>
      <remarks>

Extra data contains 0 or more values each prefixed by a header tag and length.
They contain zero or more bytes of actual data.
The data is held internally using a copy on write strategy.  This is more efficient but
means that for extra data created by passing in data can have the values modified by the caller
in some circumstances.
</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor">
      <summary>
 Initialise a default instance.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
      <summary>
 Initialise with known extra data.</summary>
      <param name="data">
The extra data.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetEntryData">
      <summary>
 Get the raw extra data value</summary>
      <returns>
Returns the raw byte[] extra data this instance represents.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Clear">
      <summary>
 Clear the stored data.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
      <summary>
 Get a read-only <see cref="Stream" /> for the associated tag.</summary>
      <returns>
Returns a <see cref="Stream" /> containing tag data or null if no tag was found.</returns>
      <param name="tag">
The tag to locate data for.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
      <summary>
 Find an extra data value</summary>
      <returns>
Returns true if the value was found; false otherwise.</returns>
      <param name="headerID">
The identifier for the value to find.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
      <summary>
 Add a new entry to extra data</summary>
      <remarks>
If the ID already exists its contents are replaced.</remarks>
      <param name="headerID">
The ID for this entry.</param>
      <param name="fieldData">
The data to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
      <summary>
 Start adding a new entry.</summary>
      <remarks>
Add data using <see cref="AddData(byte[])" />, <see cref="AddLeShort" />, <see cref="AddLeInt" />, or <see cref="AddLeLong" />.
The new entry is completed and actually added by calling <see cref="AddNewEntry" /></remarks>
      <seealso cref="AddEntry">
AddEntry</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
      <summary>
 Add entry data added since <see cref="StartNewEntry" /> using the ID passed.</summary>
      <param name="headerID">
The identifier to use for this entry.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
      <summary>
 Add a byte of data to the pending new entry.</summary>
      <seealso cref="StartNewEntry">
StartNewEntry</seealso>
      <param name="data">
The byte to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
      <summary>
 Add data to a pending new entry.</summary>
      <seealso cref="StartNewEntry">
StartNewEntry</seealso>
      <param name="data">
The data to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
      <summary>
 Add a short value in little endian order to the pending new entry.</summary>
      <seealso cref="StartNewEntry">
StartNewEntry</seealso>
      <param name="toAdd">
The data to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
      <summary>
 Add an integer value in little endian order to the pending new entry.</summary>
      <seealso cref="StartNewEntry">
StartNewEntry</seealso>
      <param name="toAdd">
The data to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
      <summary>
 Add a long value in little endian order to the pending new entry.</summary>
      <seealso cref="StartNewEntry">
StartNewEntry</seealso>
      <param name="toAdd">
The data to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
      <summary>
 Delete an extra data field.</summary>
      <returns>
Returns true if the field was found and deleted.</returns>
      <param name="headerID">
The identifier of the field to delete.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong">
      <summary>
 Read a long in little endian form from the last <see cref="Find">found</see> data value</summary>
      <returns>
Returns the long value read.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt">
      <summary>
 Read an integer in little endian form from the last <see cref="Find">found</see> data value.</summary>
      <returns>
Returns the integer read.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort">
      <summary>
 Read a short value in little endian form from the last <see cref="Find">found</see> data value.</summary>
      <returns>
Returns the short value read.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadByte">
      <summary>
 Read a byte from an extra data</summary>
      <returns>
The byte value read or -1 if the end of data has been reached.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
      <summary>
 Skip data during reading.</summary>
      <param name="amount">
The number of bytes to skip.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Dispose">
      <summary>
 Dispose of this instance.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ValueLength">
      <summary>
 Get the length of the last value found by <see cref="Find" /></summary>
      <remarks>
This is only value if <see cref="Find" /> has previsouly returned true.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
      <summary>
 Get the index for the current read value.</summary>
      <remarks>
This is only valid if <see cref="Find" /> has previously returned true.
Initially it will be the index of the first byte of actual data.  Its is updated after calls to
<see cref="ReadInt" />, <see cref="ReadShort" /> and <see cref="ReadLong" />. </remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.UnreadCount">
      <summary>
 Get the number of bytes remaining to be read for the current value;</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Length">
      <summary>
 Gets the current extra data length.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs">
      <summary>
 Arguments used with KeysRequiredEvent</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String)">
      <summary>
 Initialise a new instance of <see cref="KeysRequiredEventArgs"></see></summary>
      <param name="name">
The name of the file for which keys are required.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String,System.Byte[])">
      <summary>
 Initialise a new instance of <see cref="KeysRequiredEventArgs"></see></summary>
      <param name="name">
The name of the file for which keys are required.</param>
      <param name="keyValue">
The current key value.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.FileName">
      <summary>
 Get the name of the file for which keys are required.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.KeysRequiredEventArgs.Key">
      <summary>
 Get/set the key value</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.TestStatus">
      <summary>
 Status returned returned by <see cref="ZipTestResultHandler" /> during testing.</summary>
      <seealso cref="ZipFile.TestArchive(bool)">
TestArchive</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.TestStatus.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile)">
      <summary>
 Initialise a new instance of <see cref="TestStatus" /></summary>
      <param name="file">
The <see cref="ZipFile" /> this status applies to.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.Operation">
      <summary>
 Get the current <see cref="TestOperation" /> in progress.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.ErrorCount">
      <summary>
 Get the number of errors detected so far.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.Entry">
      <summary>
 Get the current/last entry tested.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.BytesTested">
      <summary>
 Get the number of bytes tested so far for the current entry.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.File">
      <summary>
 Get the <see cref="ZipFile" /> this status is applicable to.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.TestStatus.EntryValid">
      <summary>
 Get a value indicating wether the last entry test was valid.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipFile">
      <summary>
 This class represents a Zip archive.  You can ask for the contained entries, or get an input stream for a file entry.  The entry is automatically decompressed.  You can also update the archive adding or deleting entries.  This class is thread safe for input:  You can open input streams for arbitrary entries in different threads. <br /> <br />Author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.String)">
      <summary>
 Opens a Zip file with the given name for reading.</summary>
      <param name="name">
</param>
      <exception cref="IOException">

An i/o error occurs
</exception>
      <exception cref="ZipException">

The file doesn't contain a valid zip archive.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.IO.FileStream)">
      <summary>
 Opens a Zip file reading the given <see cref="FileStream" />.</summary>
      <param name="file">
</param>
      <exception cref="IOException">

An i/o error occurs.
</exception>
      <exception cref="ZipException">

The file doesn't contain a valid zip archive.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.#ctor(System.IO.Stream)">
      <summary>
 Opens a Zip file reading the given <see cref="Stream" />.</summary>
      <param name="stream">
</param>
      <exception cref="IOException">

An i/o error occurs
</exception>
      <exception cref="ZipException">

The file doesn't contain a valid zip archive.<br />
The stream provided cannot seek
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Close">
      <summary>
 Closes the ZipFile.  If the stream is <see cref="IsStreamOwner">owned</see> then this also closes the underlying input stream. Once closed, no further instance methods should be called.</summary>
      <exception cref="System.IO.IOException">

An i/o error occurs.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Create(System.String)">
      <summary>
 Create a new <see cref="ZipFile" /> whose data will be stored in a file.</summary>
      <returns>
Returns the newly created <see cref="ZipFile" /></returns>
      <param name="fileName">
The name of the archive to create.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Create(System.IO.Stream)">
      <summary>
 Create a new <see cref="ZipFile" /> whose data will be stored on a stream.</summary>
      <returns>
Returns the newly created <see cref="ZipFile" /></returns>
      <param name="outStream">
The stream providing data storage.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetEnumerator">
      <summary>
 Returns an enumerator for the Zip entries in this Zip file.</summary>
      <exception cref="InvalidOperationException">

The Zip file has been closed.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.FindEntry(System.String,System.Boolean)">
      <summary>
 Return the index of the entry with a matching name</summary>
      <returns>
The index position of the matching entry or -1 if not found</returns>
      <param name="name">
Entry name to find</param>
      <param name="ignoreCase">
If true the comparison is case insensitive</param>
      <exception cref="InvalidOperationException">

The Zip file has been closed.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetEntry(System.String)">
      <summary>
 Searches for a zip entry in this archive with the given name. String comparisons are case insensitive</summary>
      <returns>

A clone of the zip entry, or null if no entry with that name exists.
</returns>
      <param name="name">

The name to find. May contain directory components separated by slashes ('/').
</param>
      <exception cref="InvalidOperationException">

The Zip file has been closed.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetInputStream(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
 Creates an input stream reading the given zip entry as uncompressed data.  Normally zip entry should be an entry returned by GetEntry().</summary>
      <returns>

the input stream.
</returns>
      <param name="entry">
</param>
      <exception cref="InvalidOperationException">

The ZipFile has already been closed
</exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">

The compression method for the entry is unknown
</exception>
      <exception cref="IndexOutOfRangeException">

The entry is not found in the ZipFile
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.GetInputStream(System.Int64)">
      <summary>
 Creates an input stream reading a zip entry</summary>
      <returns>

An input stream.
</returns>
      <param name="entryIndex">
The index of the entry to obtain an input stream for.</param>
      <exception cref="InvalidOperationException">

The ZipFile has already been closed
</exception>
      <exception cref="T:ICSharpCode.SharpZipLib.Zip.ZipException">

The compression method for the entry is unknown
</exception>
      <exception cref="IndexOutOfRangeException">

The entry is not found in the ZipFile
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">
      <summary>
 Test an archive for integrity/validity</summary>
      <remarks>
Testing will terminate on the first error found.</remarks>
      <returns>
true if all tests pass, false otherwise</returns>
      <param name="testData">
Perform low level data Crc check</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICSharpCode.SharpZipLib.Zip.TestStrategy,ICSharpCode.SharpZipLib.Zip.ZipTestResultHandler)">
      <summary>
 Test an archive for integrity/validity</summary>
      <returns>
true if all tests pass, false otherwise</returns>
      <param name="testData">
Perform low level data Crc check</param>
      <param name="strategy">
The <see cref="TestStrategy"></see> to apply.</param>
      <param name="resultHandler">
The <see cref="ZipTestResultHandler"></see> handler to call during testing.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate(ICSharpCode.SharpZipLib.Zip.IArchiveStorage,ICSharpCode.SharpZipLib.Zip.IDynamicDataSource)">
      <summary>
 Begin updating this <see cref="ZipFile" /> archive.</summary>
      <param name="archiveStorage">
The <see cref="IArchiveStorage">archive storage</see> for use during the update.</param>
      <param name="dataSource">
The <see cref="IDynamicDataSource">data source</see> to utilise during updating.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate(ICSharpCode.SharpZipLib.Zip.IArchiveStorage)">
      <summary>
 Begin updating to this <see cref="ZipFile" /> archive.</summary>
      <param name="archiveStorage">
The storage to use during the update.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.BeginUpdate">
      <summary>
 Begin updating this <see cref="ZipFile" /> archive.</summary>
      <seealso cref="CommitUpdate">
CommitUpdate</seealso>
      <seealso cref="AbortUpdate">
AbortUpdate</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.CommitUpdate">
      <summary>
 Commit current updates, updating this archive.</summary>
      <seealso cref="BeginUpdate()">
BeginUpdate()</seealso>
      <seealso cref="AbortUpdate">
AbortUpdate</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AbortUpdate">
      <summary>
 Abort updating leaving the archive unchanged.</summary>
      <seealso cref="BeginUpdate()">
BeginUpdate()</seealso>
      <seealso cref="CommitUpdate">
CommitUpdate</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.SetComment(System.String)">
      <summary>
 Set the file comment to be recorded when the current update is <see cref="CommitUpdate">commited</see>.</summary>
      <param name="comment">
The comment to record.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
      <summary>
 Add a new entry to the archive.</summary>
      <param name="fileName">
The name of the file to add.</param>
      <param name="compressionMethod">
The compression method to use.</param>
      <param name="useUnicodeText">
Ensure Unicode text is used for name and comment for this entry.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
 Add a new entry to the archive.</summary>
      <param name="fileName">
The name of the file to add.</param>
      <param name="compressionMethod">
The compression method to use.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(System.String)">
      <summary>
 Add a file to the archive.</summary>
      <param name="fileName">
The name of the file to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String)">
      <summary>
 Add a file entry with data.</summary>
      <param name="dataSource">
The source of the data for this entry.</param>
      <param name="entryName">
The name to give to the entry.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
      <summary>
 Add a file entry with data.</summary>
      <param name="dataSource">
The source of the data for this entry.</param>
      <param name="entryName">
The name to give to the entry.</param>
      <param name="compressionMethod">
The compression method to use.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.IStaticDataSource,System.String,ICSharpCode.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
      <summary>
 Add a file entry with data.</summary>
      <param name="dataSource">
The source of the data for this entry.</param>
      <param name="entryName">
The name to give to the entry.</param>
      <param name="compressionMethod">
The compression method to use.</param>
      <param name="useUnicodeText">
Ensure Unicode text is used for name and comments for this entry.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Add(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
 Add a <see cref="ZipEntry" /> that contains no data.</summary>
      <remarks>
This can be used to add directories, volume labels, or empty file entries.</remarks>
      <param name="entry">
The entry to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.AddDirectory(System.String)">
      <summary>
 Add a directory entry to the archive.</summary>
      <param name="directoryName">
The directory to add.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Delete(System.String)">
      <summary>
 Delete an entry by name</summary>
      <returns>
True if the entry was found and deleted; false otherwise.</returns>
      <param name="fileName">
The filename to delete</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipFile.Delete(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
 Delete a <see cref="ZipEntry" /> from the archive.</summary>
      <param name="entry">
The entry to delete.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.NameTransform">
      <summary>
 Get / set the <see cref="INameTransform" /> to apply to names when updating.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsUpdating">
      <summary>
 Get a value indicating an update has <see cref="BeginUpdate()">been started</see>.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Count">
      <summary>
 Get the number of entries contained in this <see cref="ZipFile" />.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Password">
      <summary>
 Password to be used for encrypting/decrypting files.</summary>
      <remarks>
Set to null if no password is required.</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsNewArchive">
      <summary>
 Get a value indicating that this archive is a new one.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsEmbeddedArchive">
      <summary>
 Get a value indicating wether this archive is embedded in another file or not.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.BufferSize">
      <summary>
 Get /set the buffer size to be used when updating this zip file.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.ZipFileComment">
      <summary>
 Gets the comment for the zip file.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Size">
      <summary>
 Gets the number of entries in this zip file.</summary>
      <exception cref="InvalidOperationException">

The Zip file has been closed.
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.UseZip64">
      <summary>
 Get / set a value indicating how Zip64 Extension usage is determined when adding entries.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.EntryByIndex(System.Int32)">
      <summary>
 Indexer property for ZipEntries</summary>
      <param name="index">
</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.IsStreamOwner">
      <summary>
 Get/set a flag indicating if the underlying stream is owned by the ZipFile instance. If the flag is true then the stream will be closed when <see cref="Close">Close</see> is called.</summary>
      <remarks>

The default value is true in all cases.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipFile.Name">
      <summary>
 Gets the name of this zip file.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IStaticDataSource.GetSource">
      <summary>
 Get a data source.</summary>
      <returns>
Returns a <see cref="Stream" /> to use for compression input.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IDynamicDataSource.GetSource(ICSharpCode.SharpZipLib.Zip.ZipEntry,System.String)">
      <summary>
 Get a data source.</summary>
      <returns>
Returns a <see cref="Stream" /> to use for compression input.</returns>
      <param name="entry">
The <see cref="ZipEntry" /> to get a source for.</param>
      <param name="name">
The name for data if known.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput">
      <summary>
 Get an empty <see cref="Stream" /> that can be used for temporary output.</summary>
      <returns>
Returns a temporary output <see cref="Stream" /></returns>
      <seealso cref="ConvertTemporaryToFinal">
ConvertTemporaryToFinal</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal">
      <summary>
 Convert a temporary output stream to a final stream.</summary>
      <returns>
The resulting final <see cref="Stream" /></returns>
      <seealso cref="GetTemporaryOutput">
GetTemporaryOutput</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
 Make a temporary copy of the original stream.</summary>
      <returns>
Returns a temporary output <see cref="Stream" /> that is a copy of the input.</returns>
      <param name="stream">
The <see cref="Stream" /> to copy.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
 Return a stream suitable for performing direct updates on the original source.</summary>
      <remarks>
This may be the current stream passed.</remarks>
      <returns>
Returns a stream suitable for direct updating.</returns>
      <param name="stream">
The current stream.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.Dispose">
      <summary>
 Dispose of this instance.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.IArchiveStorage.UpdateMode">
      <summary>
 Get the <see cref="FileUpdateMode" /> to apply during updates.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage">
      <summary>
 An abstract <see cref="IArchiveStorage" /> suitable for extension by inheritance.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
 Initializes a new instance of the <see cref="BaseArchiveStorage" /> class.</summary>
      <param name="updateMode">
The update mode.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput">
      <summary>
 Gets a temporary output <see cref="Stream" /></summary>
      <returns>
Returns the temporary output stream.</returns>
      <seealso cref="ConvertTemporaryToFinal">
ConvertTemporaryToFinal</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal">
      <summary>
 Converts the temporary <see cref="Stream" /> to its final form.</summary>
      <returns>
Returns a <see cref="Stream" /> that can be used to read
the final storage for the archive.</returns>
      <seealso cref="GetTemporaryOutput">
GetTemporaryOutput</seealso>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
 Make a temporary copy of a <see cref="Stream" />.</summary>
      <returns>
Returns a temporary output <see cref="Stream" /> that is a copy of the input.</returns>
      <param name="stream">
The <see cref="Stream" /> to make a copy of.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
 Return a stream suitable for performing direct updates on the original source.</summary>
      <returns>
Returns a stream suitable for direct updating.</returns>
      <param name="stream">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.Dispose">
      <summary>
 Disposes this instance.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.BaseArchiveStorage.UpdateMode">
      <summary>
 Gets the update mode applicable.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage">
      <summary>
 An <see cref="IArchiveStorage" /> implementation suitable for hard disks.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile,ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
 Initializes a new instance of the <see cref="DiskArchiveStorage" /> class.</summary>
      <param name="file">
The file.</param>
      <param name="updateMode">
The update mode.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.ZipFile)">
      <summary>
 Initializes a new instance of the <see cref="DiskArchiveStorage" /> class.</summary>
      <param name="file">
The file.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.GetTemporaryOutput">
      <summary>
 Gets a temporary output <see cref="Stream" /> for performing updates on.</summary>
      <returns>
Returns the temporary output stream.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.ConvertTemporaryToFinal">
      <summary>
 Converts a temporary <see cref="Stream" /> to its final form.</summary>
      <returns>
Returns a <see cref="Stream" /> that can be used to read
the final storage for the archive.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
 Make a temporary copy of a stream.</summary>
      <returns>
Returns a temporary output <see cref="Stream" /> that is a copy of the input.</returns>
      <param name="stream">
The <see cref="Stream" /> to copy.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
 Return a stream suitable for performing direct updates on the original source.</summary>
      <returns>
Returns a stream suitable for direct updating.</returns>
      <param name="current">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage.Dispose">
      <summary>
 Disposes this instance.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage">
      <summary>
 An <see cref="IArchiveStorage" /> implementation suitable for in memory streams.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.#ctor">
      <summary>
 Initializes a new instance of the <see cref="MemoryArchiveStorage" /> class.</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.#ctor(ICSharpCode.SharpZipLib.Zip.FileUpdateMode)">
      <summary>
 Initializes a new instance of the <see cref="MemoryArchiveStorage" /> class.</summary>
      <remarks>
This constructor is for testing as memory streams dont really require safe mode.</remarks>
      <param name="updateMode">
The <see cref="FileUpdateMode" /> to use</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.GetTemporaryOutput">
      <summary>
 Gets the temporary output <see cref="Stream" /></summary>
      <returns>
Returns the temporary output stream.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal">
      <summary>
 Converts the temporary <see cref="Stream" /> to its final form.</summary>
      <returns>
Returns a <see cref="Stream" /> that can be used to read
the final storage for the archive.</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
      <summary>
 Make a temporary copy of the original stream.</summary>
      <returns>
Returns a temporary output <see cref="Stream" /> that is a copy of the input.</returns>
      <param name="stream">
The <see cref="Stream" /> to copy.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
      <summary>
 Return a stream suitable for performing direct updates on the original source.</summary>
      <returns>
Returns a stream suitable for direct updating.</returns>
      <param name="stream">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.Dispose">
      <summary>
 Disposes this instance.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.MemoryArchiveStorage.FinalStream">
      <summary>
 Get the stream returned by <see cref="ConvertTemporaryToFinal" /> if this was in fact called.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipInputStream">
      <summary>
 This is an InflaterInputStream that reads the files baseInputStream an zip archive one after another.  It has a special method to get the zip entry of the next file.  The zip entry contains information about the file name size, compressed size, Crc, etc. It includes support for Stored and Deflated entries. <br /> <br />Author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.#ctor(System.IO.Stream)">
      <summary>
 Creates a new Zip input stream, for reading a zip archive.</summary>
      <param name="baseInputStream">
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.GetNextEntry">
      <summary>
 Advances to the next entry in the archive</summary>
      <remarks>

If the previous entry is still open <see cref="CloseEntry">CloseEntry</see> is called.
</remarks>
      <returns>

The next <see cref="ZipEntry">entry</see> in the archive or null if there are no more entries.
</returns>
      <exception cref="InvalidOperationException">

Input stream is closed
</exception>
      <exception cref="ZipException">

Password is not set, password is invalid, compression method is invalid,
version required to extract is not supported
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CloseEntry">
      <summary>
 Closes the current zip entry and moves to the next one.</summary>
      <exception cref="InvalidOperationException">

The stream is closed
</exception>
      <exception cref="ZipException">

The Zip stream ends early
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.ReadByte">
      <summary>
 Reads a byte from the current zip entry.</summary>
      <returns>

The byte or -1 if end of stream is reached.
</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Read a block of bytes from the stream.</summary>
      <remarks>
Zero bytes read means end of stream.</remarks>
      <returns>
Returns the number of bytes read.</returns>
      <param name="buffer">
The destination for the bytes.</param>
      <param name="offset">
The index to start storing data.</param>
      <param name="count">
The number of bytes to attempt to read.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Close">
      <summary>
 Closes the zip input stream</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.CanDecompressEntry">
      <summary>
 Gets a value indicating if there is a current entry  and it can be decompressed</summary>
      <remarks>

The entry can only be decompressed if the library supports the zip features required to extract it.
See the <see cref="ZipEntry.Version">ZipEntry Version</see> property for more details.
</remarks>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Available">
      <summary>
 Returns 1 if there is an entry available Otherwise returns 0.</summary>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Length">
      <summary>
 Returns the current size that can be read from the current entry if available</summary>
      <exception cref="ZipException">
Thrown if the entry size is not known.</exception>
      <exception cref="InvalidOperationException">
Thrown if no entry is currently available.</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipInputStream.Password">
      <summary>
 Optional password used for encryption when non-null</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipNameTransform">
      <summary>
 ZipNameTransform transforms names as per the Zip file naming convention.</summary>
      <remarks>
The use of absolute names is supported although its use is not valid
according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.#ctor">
      <summary>
 Initialize a new instance of <see cref="ZipNameTransform"></see></summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.#ctor(System.String)">
      <summary>
 Initialize a new instance of <see cref="ZipNameTransform"></see></summary>
      <param name="trimPrefix">
The string to trim from front of paths if found.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TransformDirectory(System.String)">
      <summary>
 Transform a directory name according to the Zip file naming conventions.</summary>
      <returns>
The transformed name.</returns>
      <param name="name">
The directory name to transform.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TransformFile(System.String)">
      <summary>
 Transform a file name according to the Zip file naming conventions.</summary>
      <returns>
The transformed name.</returns>
      <param name="name">
The file name to transform.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String,System.Boolean)">
      <summary>
 Test a name to see if it is a valid name for a zip entry.</summary>
      <remarks>
Zip path names are actually in Unix format,
and should only contain relative paths.
This means that any path stored should not contain a drive or
device letter, or a leading slash.  All slashes should forward slashes '/'.
An empty name is valid for a file where the input comes from standard input.
A null name is not considered valid.
</remarks>
      <returns>
Returns true if the name is a valid zip name; false otherwise.</returns>
      <param name="name">
The name to test.</param>
      <param name="relaxed">
If true checking is relaxed about windows file names and absolute paths.</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String)">
      <summary>
 Test a name to see if it is a valid name for a zip entry.</summary>
      <remarks>
Zip path names are actually in unix format,
and should only contain relative paths if a path is present.
This means that the path stored should not contain a drive or
device letter, or a leading slash.  All slashes should forward slashes '/'.
An empty name is valid where the input comes from standard input.
A null name is not considered valid.
</remarks>
      <returns>
Returns true if the name is a valid zip name; false otherwise.</returns>
      <param name="name">
The name to test.</param>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipNameTransform.TrimPrefix">
      <summary>
 Get/set the path prefix to be trimmed from paths if present.</summary>
</member>
    <member name="T:ICSharpCode.SharpZipLib.Zip.ZipOutputStream">
      <summary>
 This is a DeflaterOutputStream that writes the files into a zip archive one after another.  It has a special method to start a new zip entry.  The zip entries contains information about the file name size, compressed size, CRC, etc.  It includes support for Stored and Deflated entries. This class is not thread safe. <br /> <br />Author of the original java version : Jochen Hoenicke</summary>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
      <summary>
 Creates a new Zip output stream, writing a zip archive.</summary>
      <param name="baseOutputStream">

The output stream to which the archive contents are written.
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.SetComment(System.String)">
      <summary>
 Set the zip file comment.</summary>
      <param name="comment">

The comment string
</param>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.SetLevel(System.Int32)">
      <summary>
 Sets default compression level.  The new level will be activated immediately.</summary>
      <param name="level">
</param>
      <exception cref="ArgumentOutOfRangeException">

Level specified is not supported.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.GetLevel">
      <summary>
 Get the current deflate compression level</summary>
      <returns>
The current compression level</returns>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.PutNextEntry(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
      <summary>
 Starts a new Zip entry. It automatically closes the previous entry if present. All entry elements bar name are optional, but must be correct if present. If the compression method is stored and the output is not patchable the compression for that entry is automatically changed to deflate level 0</summary>
      <param name="entry">

the entry.
</param>
      <exception cref="System.ArgumentNullException">

if entry passed is null.
</exception>
      <exception cref="System.IO.IOException">

if an I/O error occured.
</exception>
      <exception cref="System.InvalidOperationException">

if stream was finished
</exception>
      <exception cref="ZipException">

Too many entries in the Zip file<br />
Entry name is too long<br />
Finish has already been called<br />
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.CloseEntry">
      <summary>
 Closes the current entry, updating header and footer information as required</summary>
      <exception cref="System.IO.IOException">

An I/O error occurs.
</exception>
      <exception cref="System.InvalidOperationException">

No entry is active.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
 Writes the given buffer to the current entry.</summary>
      <param name="buffer">
</param>
      <param name="offset">
</param>
      <param name="count">
</param>
      <exception cref="ZipException">

Archive size is invalid
</exception>
      <exception cref="System.InvalidOperationException">

No entry is active.
</exception>
</member>
    <member name="M:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.Finish">
      <summary>
 Finishes the stream.  This will write the central directory at the end of the zip file and flush the stream.</summary>
      <remarks>

This is automatically called when the stream is closed.
</remarks>
      <exception cref="System.IO.IOException">

An I/O error occurs.
</exception>
      <exception cref="ZipException">

Comment exceeds the maximum length<br />
Entry name exceeds the maximum length
</exception>
</member>
    <member name="P:ICSharpCode.SharpZipLib.Zip.ZipOutputStream.IsFinished">
      <summary>
 Gets boolean indicating central header has been added for this archive... No further entries can be added once this has been done.</summary>
</member>
    <member name="N:">
</member>
  </members>
</doc>
